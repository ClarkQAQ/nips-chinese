NIP-15
======

Nostr 市场
-----------------

`草案` `可选`

基于 [Diagon-Alley](https://github.com/lnbits/Diagon-Alley)。

在 [NostrMarket](https://github.com/lnbits/nostrmarket) 和 [Plebeian Market](https://github.com/PlebeianTech/plebeian-market) 中实现。

## 术语

- `merchant`（商家） - 具有 NOSTR 密钥对的产品销售者
- `customer`（客户） - 具有 NOSTR 密钥对的产品购买者
- `product`（产品） - 由 `merchant` 销售的物品
- `stall`（摊位） - 由 `merchant` 控制的产品列表（一个 `merchant` 可以有多个摊位）
- `marketplace`（市场） - 用于搜索 `stalls` 和购买 `products` 的客户端软件

## Nostr 市场客户端

### 商家管理

`merchant` 在此处创建、更新和删除 `stalls` 和 `products`，以及管理销售、付款和与 `customers` 的沟通。

`merchant` 管理软件可以是纯客户端的，但为了 `convenience` 和正常运行时间，实现可能会有一个服务器客户端监听 NOSTR 事件。

### 市场

`Marketplace` 软件应该完全是客户端的，要么作为独立应用程序，要么作为纯前端网页。`customer` 订阅不同的商家 NOSTR 公钥，这些 `merchants` 的 `stalls` 和 `products` 变得可列出和可搜索。市场客户端就像任何其他电子商务网站一样，有购物篮和结账。`Marketplaces` 可能也希望包括一个 `customer` 支持区域，用于与 `merchants` 的直接消息通信。

## `Merchant` 发布/更新产品（事件）

商家可以发布这些事件：
| 种类      |                    | 描述                                                                                                     |
| --------- | ------------------ | --------------------------------------------------------------------------------------------------------------- |
| `0`       | `set_meta`         | 商家描述（与任何 `nostr` 公钥类似）。                                                 |
| `30017`   | `set_stall`        | 创建或更新摊位。                                                                                       |
| `30018`   | `set_product`      | 创建或更新产品。                                                                                     |
| `4`       | `direct_message`   | 与客户沟通。消息可以是纯文本或 JSON。                                          |
| `5`       | `delete`           | 删除产品或摊位。                                                                                    |

### 事件 `30017`：创建或更新摊位。

**事件内容**

```json
{
  "id": <字符串，商家生成的 id。不鼓励连续 ID（`0`、`1`、`2`...）>,
  "name": <字符串，摊位名称>,
  "description": <字符串（可选），摊位描述>,
  "currency": <字符串，使用的货币>,
  "shipping": [
    {
      "id": <字符串，商家生成的运输区域 id>,
      "name": <字符串（可选），区域名称>,
      "cost": <浮点数，运输基础费用。货币在摊位级别定义>,
      "regions": [<字符串，此区域包含的地区>]
    }
  ]
}
```

不言自明的字段：
| - `shipping`:
|   - 此摊位可能的运输区域数组。
|   - 客户必须选择这些运输区域中的一个。
|   - 运输到不同区域可能有不同费用。对于某些商品（例如数字商品），费用可以为零。
|   - `id` 是商家使用的内部值。此值必须作为客户选择发送回来。
|   - 每个运输区域包含向该运输区域下单的基础费用，但如果该产品的运输费用高于基础费用指定的费用，也可以指定每个产品的特定运输费用。

**事件标签**

```jsonc
{
  "tags": [["d", <字符串，摊位 id>]],
  // 其他字段...
}
```
| - `d` 标签是必需的，其值必须与摊位 `id` 相同。

### 事件 `30018`：创建或更新产品

**事件内容**

```json
{
  "id": <字符串，商家生成的 id（不鼓励连续 id）>,
  "stall_id": <字符串，此产品所属摊位的 id>,
  "name": <字符串，产品名称>,
  "description": <字符串（可选），产品描述>,
  "images": <[字符串]，图像 URL 数组，可选>,
  "currency": <字符串，使用的货币>,
  "price": <浮点数，产品费用>,
  "quantity": <整数或 null，可用物品>,
  "specs": [
    [<字符串，规格键>, <字符串，规格值>]
  ],
  "shipping": [
    {
      "id": <字符串，运输区域 id（必须匹配为摊位定义的区域之一）>,
      "cost": <浮点数，运输额外费用。货币在摊位级别定义>
    }
  ]
}
```

不言自明的字段：
| - `quantity` 在无限可用性物品的情况下可以为 null，如数字物品或服务
| - `specs`:
|   - 键值对的可选数组。它允许客户 UI 以结构模式呈现产品规格。它还允许产品之间的比较
|   - 例如：`[["operating_system", "Android 12.0"], ["screen_size", "6.4 inches"], ["connector_type", "USB Type C"]]`

    _开放_：将 `spec` 移动到事件的 `tags` 部分是否更好？

|- `shipping`:
|   - 每个运输区域使用的额外费用的_可选_数组，仅适用于需要将特殊运输费用添加到摊位中定义的基础运输费用的产品
|   - `id` 应该匹配运输区域的 id，如摊位的 `shipping` 字段中定义
|   - 要计算订单的总运输费用，用户将在结账期间选择运输选项，然后客户端必须考虑这些费用：
|     - 选择的运输选项的 `摊位基础费用`
|     - 将产品单位乘以 `产品中指定的运输费用`（如果有）的结果。

**事件标签**

```jsonc
  "tags": [
    ["d", <字符串，产品 id>],
    ["t", <字符串（可选），产品类别>],
    ["t", <字符串（可选），产品类别>],
    // 其他字段...
  ],
  ...
```

| - `d` 标签是必需的，其值必须与产品 `id` 相同。
| - `t` 标签作为可搜索标签，它表示产品可以属于的不同类别（`food`、`fruits`）。可以存在多个 `t` 标签。

## 结账事件

所有结账事件都使用 [NIP-04](04.md) 作为 JSON 字符串发送。

`merchant` 和 `customer` 可以交换表示不同操作的 JSON 消息。每个 `JSON` 消息必须有一个 `type` 字段，指示 JSON 表示什么。可能的类型：

| 消息类型 | 发送者  | 描述         |
|--------------|----------|---------------------|
| 0            | Customer | 新订单           |
| 1            | Merchant | 付款请求     |
| 2            | Merchant | 订单状态更新 |

### 步骤 1：`customer` 订单（事件）
下面的 JSON 放在 [NIP-04](04.md) 的内容中。

```json
{
  "id": <字符串，客户生成的 id>,
  "type": 0,
  "name": <字符串（可选），???>,
  "address": <字符串（可选），对于实物商品应提供地址>,
  "message": <字符串（可选），给商家的消息>,
  "contact": {
    "nostr": <公钥的 32 字节十六进制>,
    "phone": <字符串（可选），如果客户希望通过电话联系>,
    "email": <字符串（可选），如果客户希望通过电子邮件联系>
  },
  "items": [
    {
      "product_id": <字符串，产品 id>,
      "quantity": <整数，客户订购的产品数量>
    }
  ],
  "shipping_id": <字符串，运输区域 id>
}

```

_开放_：`contact.nostr` 是必需的吗？


### 步骤 2：`merchant` 请求付款（事件）

从商家发送回来请求付款。商家可以检查的任何付款选项都是有效的。

下面的 JSON 放在 [NIP-04](04.md) 的 `content` 中。

`payment_options`/`type` 包括：

- `url` 付款页面的 URL，stripe、paypal、btcpayserver 等
- `btc` 链上比特币地址
- `ln` 比特币闪电发票
- `lnurl` 比特币 lnurl-pay

```json
{
  "id": <字符串，订单 id>,
  "type": 1,
  "message": <字符串，给客户的消息，可选>,
  "payment_options": [
    {
      "type": <字符串，选项类型>,
      "link": <字符串，url、btc 地址、ln 发票等>
    },
    {
      "type": <字符串，选项类型>,
      "link": <字符串，url、btc 地址、ln 发票等>
    },
    {
      "type": <字符串，选项类型>,
      "link": <字符串，url、btc 地址、ln 发票等>
    }
  ]
}
```

### 步骤 3：`merchant` 验证付款/已发货（事件）

一旦收到并处理付款。

下面的 JSON 放在 [NIP-04](04.md) 的 `content` 中。

```json
{
  "id": <字符串，订单 id>,
  "type": 2,
  "message": <字符串，给客户的消息>,
  "paid": <布尔值：已收到付款>,
  "shipped": <布尔值：已发货>,
}
```

## 自定义市场

使用来自 [NIP-19](19.md#shareable-identifiers-with-extra-metadata) 的 `naddr` 创建自定义用户体验。使用 `naddr` 可以轻松共享市场事件，同时包含丰富的元数据集。此元数据可以包括中继器、商家档案等。随后，它允许将商家分组到市场中，使市场创建者能够配置市场的用户界面和用户体验，并共享该市场。此自定义可以包含市场名称、描述、徽标、横幅、主题甚至配色方案等元素，提供定制和独特的市场体验。

### 事件 `30019`：创建或更新市场 UI/UX

**事件内容**

```jsonc
{
  "name": <字符串（可选），市场名称>,
  "about": <字符串（可选），市场描述>,
  "ui": {
    "picture": <字符串（可选），市场徽标图像 URL>,
    "banner": <字符串（可选），市场徽标横幅 URL>,
    "theme": <字符串（可选），市场主题>,
    "darkMode": <布尔值，true/false>
  },
  "merchants": [公钥数组（可选）],
  // 其他字段...
}
```

此事件利用 naddr 实现市场配置的全面自定义和共享，培育独特且引人入胜的市场环境。

## 拍卖

### 事件 `30020`：创建或更新作为拍卖出售的产品

**事件内容**：
```json
{
    "id": <字符串，商家生成的 UUID。不鼓励连续 ID（`0`、`1`、`2`...）>,
    "stall_id": <字符串，此产品所属摊位的 UUID>,
    "name": <字符串，产品名称>,
    "description": <字符串（可选），产品描述>,
    "images": <[字符串]，图像 URL 数组，可选>,
    "starting_bid": <整数>,
    "start_date": <整数（可选）UNIX 时间戳，拍卖开始/将开始的日期>,
    "duration": <整数，拍卖将运行的秒数，不包括可能发生的最终时间延长>,
    "specs": [
        [<字符串，规格键>, <字符串，规格值>]
    ],
    "shipping": [
        {
            "id": <字符串，运输区域的 UUID。必须匹配为摊位定义的区域之一>,
            "cost": <浮点数，运输额外费用。货币在摊位级别定义>
        }
    ]
}
```

> [!NOTE]
> 作为拍卖出售的物品在结构上与固定价格物品非常相似，但有一些值得注意的重要差异。

* 如果拍卖计划在该日期开始，`start_date` 可以设置为将来的日期，或者如果开始日期未知/隐藏，可以省略。如果未指定开始日期，拍卖将必须稍后编辑以设置实际日期。

* 拍卖在 `start_date` 之后运行初始秒数，由 `duration` 指定。

### 事件 `1021`：竞价

```jsonc
{
    "content": <整数，聪数量>,
    "tags": [["e", <要竞价的拍卖事件 ID>]],
    // 其他字段...
}
```

竞价只是种类为 `1021` 的事件，`content` 字段指定拍卖货币中的金额。竞价必须引用拍卖。

> [!NOTE]
> 拍卖可以由作者随意编辑多次（它们是"可寻址事件"）- 即使在 start_date 之后，但在收到第一个竞价后不能编辑！这是因为竞价引用拍卖的事件 ID（而不是产品 UUID），每个拍卖产品的新版本都会改变。因此竞价总是附加到一个"版本"。在竞价后编辑拍卖将导致新产品失去竞价！

### 事件 `1022`：竞价确认

**事件内容**：

```json
{
    "status": <字符串，"accepted" | "rejected" | "pending" | "winner">,
    "message": <字符串（可选）>,
    "duration_extended": <整数（可选），秒数>
}
```

**事件标签**：
```json
  "tags": [["e" <被确认竞价的事件 ID>], ["e", <拍卖的事件 ID>]],
```

竞价应该由商家确认后才能被其他客户端视为有效。因此客户端应该为他们关注的每个拍卖订阅*竞价确认*事件（种类 `1022`），除了实际竞价之外，还应该检查竞价确认的公钥是否匹配商家的公钥（除了检查签名）。

`content` 字段是包含*至少*一个 `status` 的 JSON。`winner` 是拍卖结束后选择获胜竞价后对*获胜竞价*的回复方式。

竞价可以被标记为 `rejected` 或 `pending` 的原因取决于商家的实现和配置 - 它们可以是从基本验证错误（金额太低）到竞价者被列入黑名单或竞价者缺乏足够的*信任*的任何原因，这可能导致竞价被标记为 `pending`，直到执行足够的验证。两者之间的区别是 `pending` 竞价在竞价者采取额外步骤后*可能*获得批准，而 `rejected` 竞价不能稍后批准。

额外的 `message` 字段可以出现在 `content` JSON 中，以提供关于竞价为何被 `rejected` 或 `pending` 的进一步上下文。

另一件可能发生的事情是 - 如果竞价发生在拍卖结束日期附近 - 商家决定将拍卖持续时间延长几分钟。这通过将 `duration_extended` 字段作为竞价确认的一部分来完成，该字段将包含延长初始持续时间的秒数。因此拍卖的实际结束日期始终是 `start_date + duration + (SUM(c.duration_extended) FOR c in all confirmations)`。

## 客户支持事件

客户支持通过指定的任何通信方法处理。如果通过 nostr 通信，使用 [NIP-04](04.md)。

## 附加

标准数据模型可以在[这里](https://raw.githubusercontent.com/lnbits/nostrmarket/main/models.py)找到
