NIP-55
======

Android 签名应用程序
--------------------------

`草案` `可选`

本 NIP 描述了 Android 签名器和 Android 上任何 Nostr 客户端之间双向通信的方法。Android 签名器是一个 Android 应用程序，客户端可以是 Web 客户端或 Android 应用程序。

## Android 应用程序的使用

Android 签名器使用意图（手动接受/拒绝权限）和内容解析器（如果用户允许，在后台自动接受/拒绝权限）在应用程序之间进行通信。

要在您的应用程序中使用 Android 签名器，您应该将此添加到您的 AndroidManifest.xml：

```xml
<queries>
  <intent>
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.BROWSABLE" />
    <data android:scheme="nostrsigner" />
  </intent>
</queries>
```

然后您可以使用此函数检查是否安装了签名器应用程序：

```kotlin
fun isExternalSignerInstalled(context: Context): Boolean {
  val intent =
    Intent().apply {
      action = Intent.ACTION_VIEW
      data = Uri.parse("nostrsigner:")
    }
  val infos = context.packageManager.queryIntentActivities(intent, 0)
  return infos.size > 0
}
```

### 使用意图

要从签名器应用程序获取结果，您应该在 Kotlin 中使用 `registerForActivityResult` 或 `rememberLauncherForActivityResult`。如果您使用其他框架，请查看您的框架或第三方库的文档以获取结果。

```kotlin
val launcher = rememberLauncherForActivityResult(
    contract = ActivityResultContracts.StartActivityForResult(),
    onResult = { result ->
        if (result.resultCode != Activity.RESULT_OK) {
            Toast.makeText(
                context,
                "签名请求被拒绝",
                Toast.LENGTH_SHORT
            ).show()
        } else {
            val result = activityResult.data?.getStringExtra("result")
            // 对结果做些什么...
        }
    }
)
```

使用 **nostrsigner** 方案创建意图：

```kotlin
val intent = Intent(Intent.ACTION_VIEW, Uri.parse("nostrsigner:$content"))
```

在收到来自 **get_public_key** 方法的响应后设置签名器包名：

```kotlin
intent.`package` = "com.example.signer"
```

如果您发送多个意图而不等待，您可以添加一些意图标志来签署所有事件而不多次打开签名器

```kotlin
intent.addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP or Intent.FLAG_ACTIVITY_CLEAR_TOP)
```

如果您正在开发签名器应用程序，则需要将此添加到您的 AndroidManifest.xml，以便客户端可以使用上述意图标志

```kotlin
android:launchMode="singleTop"
```

签名器必须用结果数组回答多个权限

```kotlin

val results = listOf(
  Result(
    package = signerPackageName,
    result = eventSignature,
    id = intentId
  )
)

val json = results.toJson()

intent.putExtra("results", json)
```

发送意图：

```kotlin
launcher.launch(intent)
```

#### 方法

- **get_public_key**
  - 参数：

    ```kotlin
    val intent = Intent(Intent.ACTION_VIEW, Uri.parse("nostrsigner:"))
    intent.putExtra("type", "get_public_key")
    // 您可以为用户发送一些默认权限以永久授权
    val permissions = listOf(
      Permission(
          type = "sign_event",
          kind = 22242
      ),
      Permission(
          type = "nip44_decrypt"
      )
    )
    intent.putExtra("permissions", permissions.toJson())
    context.startActivity(intent)
    ```
  - 结果：
    - 如果用户批准意图，它将在结果字段中返回 **pubkey**，在 **package** 字段中返回签名器包名

      ```kotlin
      val pubkey = intent.data?.getStringExtra("result")
      // 签名器应用程序的包名
      val packageName = intent.data?.getStringExtra("package")
      ```

- **sign_event**
  - 参数：

    ```kotlin
    val intent = Intent(Intent.ACTION_VIEW, Uri.parse("nostrsigner:$eventJson"))
    intent.`package` = "com.example.signer"
    intent.putExtra("type", "sign_event")
    // 处理意图之间不等待时的结果
    intent.putExtra("id", event.id)
    // 发送当前登录用户公钥
    intent.putExtra("current_user", pubkey)

    context.startActivity(intent)
    ```
  - 结果：
    - 如果用户批准意图，它将返回 **result**、**id** 和 **event** 字段

      ```kotlin
      val signature = intent.data?.getStringExtra("result")
      // 您发送的 ID
      val id = intent.data?.getStringExtra("id")
      val signedEventJson = intent.data?.getStringExtra("event")
      ```

- **nip04_encrypt**
  - 参数：

    ```kotlin
    val intent = Intent(Intent.ACTION_VIEW, Uri.parse("nostrsigner:$plaintext"))
    intent.`package` = "com.example.signer"
    intent.putExtra("type", "nip04_encrypt")
    // 控制应用程序中的结果，以防您在发送另一个意图之前不等待结果
    intent.putExtra("id", "some_id")
    // 发送当前登录用户公钥
    intent.putExtra("current_user", account.keyPair.pubkey)
    // 发送将用于加密数据的十六进制公钥
    intent.putExtra("pubkey", pubkey)

    context.startActivity(intent)
    ```
  - 结果：
    - 如果用户批准意图，它将返回 **result** 和 **id** 字段

      ```kotlin
      val encryptedText = intent.data?.getStringExtra("result")
      // 您发送的 ID
      val id = intent.data?.getStringExtra("id")
      ```

- **nip44_encrypt**
  - 参数：

    ```kotlin
    val intent = Intent(Intent.ACTION_VIEW, Uri.parse("nostrsigner:$plaintext"))
    intent.`package` = "com.example.signer"
    intent.putExtra("type", "nip44_encrypt")
    // 控制应用程序中的结果，以防您在发送另一个意图之前不等待结果
    intent.putExtra("id", "some_id")
    // 发送当前登录用户公钥
    intent.putExtra("current_user", account.keyPair.pubkey)
    // 发送将用于加密数据的十六进制公钥
    intent.putExtra("pubkey", pubkey)

    context.startActivity(intent)
    ```
  - 结果：
    - 如果用户批准意图，它将返回 **signature** 和 **id** 字段

      ```kotlin
      val encryptedText = intent.data?.getStringExtra("signature")
      // 您发送的 ID
      val id = intent.data?.getStringExtra("id")
      ```

- **nip04_decrypt**
  - 参数：

    ```kotlin
    val intent = Intent(Intent.ACTION_VIEW, Uri.parse("nostrsigner:$encryptedText"))
    intent.`package` = "com.example.signer"
    intent.putExtra("type", "nip04_decrypt")
    // 控制应用程序中的结果，以防您在发送另一个意图之前不等待结果
    intent.putExtra("id", "some_id")
    // 发送当前登录用户公钥
    intent.putExtra("current_user", account.keyPair.pubkey)
    // 发送将用于解密数据的十六进制公钥
    intent.putExtra("pubkey", pubkey)

    context.startActivity(intent)
    ```
  - 结果：
    - 如果用户批准意图，它将返回 **result** 和 **id** 字段

      ```kotlin
      val plainText = intent.data?.getStringExtra("result")
      // 您发送的 ID
      val id = intent.data?.getStringExtra("id")
      ```

- **nip44_decrypt**
  - 参数：

    ```kotlin
    val intent = Intent(Intent.ACTION_VIEW, Uri.parse("nostrsigner:$encryptedText"))
    intent.`package` = "com.example.signer"
    intent.putExtra("type", "nip04_decrypt")
    // 控制应用程序中的结果，以防您在发送另一个意图之前不等待结果
    intent.putExtra("id", "some_id")
    // 发送当前登录用户公钥
    intent.putExtra("current_user", account.keyPair.pubkey)
    // 发送将用于解密数据的十六进制公钥
    intent.putExtra("pubkey", pubkey)

    context.startActivity(intent)
    ```
  - 结果：
    - 如果用户批准意图，它将返回 **result** 和 **id** 字段

      ```kotlin
      val plainText = intent.data?.getStringExtra("result")
      // 您发送的 ID
      val id = intent.data?.getStringExtra("id")
      ```

- **decrypt_zap_event**
  - 参数：

    ```kotlin
    val intent = Intent(Intent.ACTION_VIEW, Uri.parse("nostrsigner:$eventJson"))
    intent.`package` = "com.example.signer"
    intent.putExtra("type", "decrypt_zap_event")
    // 控制应用程序中的结果，以防您在发送另一个意图之前不等待结果
    intent.putExtra("id", "some_id")
    // 发送当前登录用户公钥
    intent.putExtra("current_user", account.keyPair.pubkey)
    context.startActivity(intent)
    ```
  - 结果：
    - 如果用户批准意图，它将返回 **result** 和 **id** 字段

      ```kotlin
      val eventJson = intent.data?.getStringExtra("result")
      // 您发送的 ID
      val id = intent.data?.getStringExtra("id")
      ```

### 使用内容解析器

要从签名器应用程序获取结果，您应该在 Kotlin 中使用 contentResolver.query。如果您使用其他框架，请查看您的框架或第三方库的文档以获取结果。

如果用户没有勾选"记住我的选择"选项，公钥不在签名器应用程序中或签名器类型不被识别，`contentResolver` 将返回 null

对于 SIGN_EVENT 类型，签名器应用程序返回两列"result"和"event"。列 event 是已签名的事件 json

对于其他类型，签名器应用程序返回列"result"

如果用户选择始终拒绝事件，签名器应用程序将返回列"rejected"，您不应该打开签名器应用程序

#### 方法

- **get_public_key**
  - 参数：

    ```kotlin
    val result = context.contentResolver.query(
        Uri.parse("content://com.example.signer.GET_PUBLIC_KEY"),
        listOf("login"),
        null,
        null,
        null
    )
    ```
  - 结果：
    - 将在结果列中返回 **pubkey**

      ```kotlin
        if (result == null) return

        if (it.getColumnIndex("rejected") > -1) return

        if (result.moveToFirst()) {
            val index = it.getColumnIndex("result")
            if (index < 0) return
            val pubkey = it.getString(index)
        }
      ```

- **sign_event**
  - 参数：

    ```kotlin
    val result = context.contentResolver.query(
        Uri.parse("content://com.example.signer.SIGN_EVENT"),
        listOf("$eventJson", "", "${logged_in_user_pubkey}"),
        null,
        null,
        null
    )
    ```
  - 结果：
    - 将返回 **result** 和 **event** 列

      ```kotlin
        if (result == null) return

        if (it.getColumnIndex("rejected") > -1) return

        if (result.moveToFirst()) {
            val index = it.getColumnIndex("result")
            val indexJson = it.getColumnIndex("event")
            val signature = it.getString(index)
            val eventJson = it.getString(indexJson)
        }
      ```

- **nip04_encrypt**
  - 参数：

    ```kotlin
    val result = context.contentResolver.query(
        Uri.parse("content://com.example.signer.NIP04_ENCRYPT"),
        listOf("$plainText", "${hex_pub_key}", "${logged_in_user_pubkey}"),
        null,
        null,
        null
    )
    ```
  - 结果：
    - 将返回 **result** 列

      ```kotlin
        if (result == null) return

        if (it.getColumnIndex("rejected") > -1) return

        if (result.moveToFirst()) {
            val index = it.getColumnIndex("result")
            val encryptedText = it.getString(index)
        }
      ```

- **nip44_encrypt**
  - 参数：

    ```kotlin
    val result = context.contentResolver.query(
        Uri.parse("content://com.example.signer.NIP44_ENCRYPT"),
        listOf("$plainText", "${hex_pub_key}", "${logged_in_user_pubkey}"),
        null,
        null,
        null
    )
    ```
  - 结果：
    - 将返回 **result** 列

      ```kotlin
        if (result == null) return

        if (it.getColumnIndex("rejected") > -1) return

        if (result.moveToFirst()) {
            val index = it.getColumnIndex("result")
            val encryptedText = it.getString(index)
        }
      ```

- **nip04_decrypt**
  - 参数：

    ```kotlin
    val result = context.contentResolver.query(
        Uri.parse("content://com.example.signer.NIP04_DECRYPT"),
        listOf("$encryptedText", "${hex_pub_key}", "${logged_in_user_pubkey}"),
        null,
        null,
        null
    )
    ```
  - 结果：
    - 将返回 **result** 列

      ```kotlin
        if (result == null) return

        if (it.getColumnIndex("rejected") > -1) return

        if (result.moveToFirst()) {
            val index = it.getColumnIndex("result")
            val encryptedText = it.getString(index)
        }
      ```

- **nip44_decrypt**
  - 参数：

    ```kotlin
    val result = context.contentResolver.query(
        Uri.parse("content://com.example.signer.NIP44_DECRYPT"),
        listOf("$encryptedText", "${hex_pub_key}", "${logged_in_user_pubkey}"),
        null,
        null,
        null
    )
    ```
  - 结果：
    - 将返回 **result** 列

      ```kotlin
        if (result == null) return

        if (it.getColumnIndex("rejected") > -1) return

        if (result.moveToFirst()) {
            val index = it.getColumnIndex("result")
            val encryptedText = it.getString(index)
        }
      ```

- **decrypt_zap_event**
  - 参数：

    ```kotlin
    val result = context.contentResolver.query(
        Uri.parse("content://com.example.signer.DECRYPT_ZAP_EVENT"),
        listOf("$eventJson", "", "${logged_in_user_pubkey}"),
        null,
        null,
        null
    )
    ```
  - 结果：
    - 将返回 **result** 列

      ```kotlin
        if (result == null) return

        if (it.getColumnIndex("rejected") > -1) return

        if (result.moveToFirst()) {
            val index = it.getColumnIndex("result")
            val eventJson = it.getString(index)
        }
      ```

## Web 应用程序的使用

您应该考虑使用 [NIP-46: Nostr Connect](46_ZH.md) 为 Web 应用程序提供更好的体验。使用这种方法时，Web 应用程序无法在后台调用签名器，因此用户将看到您尝试签署的每个事件的弹出窗口。

由于 Web 应用程序无法从意图接收结果，您应该添加一个模态来粘贴签名或事件 json 或创建回调 URL。

如果您发送回调 URL 参数，签名器应用程序将向该 URL 发送结果。

如果您不发送回调 URL，签名器应用程序将将结果复制到剪贴板。

您可以配置 `returnType` 为 **signature** 或 **event**。

Android 意图和浏览器 URL 有限制，因此如果您使用 **event** 的 `returnType`，请考虑使用参数 **compressionType=gzip**，它将返回"Signer1" + Base64 gzip 编码的事件 json

### 方法

- **get_public_key**
  - 参数：

    ```js
    window.href = `nostrsigner:?compressionType=none&returnType=signature&type=get_public_key&callbackUrl=https://example.com/?event=`;
    ```

- **sign_event**
  - 参数：

    ```js
    window.href = `nostrsigner:${eventJson}?compressionType=none&returnType=signature&type=sign_event&callbackUrl=https://example.com/?event=`;
    ```

- **nip04_encrypt**
  - 参数：

    ```js
    window.href = `nostrsigner:${plainText}?pubkey=${hex_pub_key}&compressionType=none&returnType=signature&type=nip04_encrypt&callbackUrl=https://example.com/?event=`;
    ```

- **nip44_encrypt**
  - 参数：

    ```js
    window.href = `nostrsigner:${plainText}?pubkey=${hex_pub_key}&compressionType=none&returnType=signature&type=nip44_encrypt&callbackUrl=https://example.com/?event=`;
    ```

- **nip04_decrypt**
  - 参数：

    ```js
    window.href = `nostrsigner:${encryptedText}?pubkey=${hex_pub_key}&compressionType=none&returnType=signature&type=nip04_decrypt&callbackUrl=https://example.com/?event=`;
    ```

- **nip44_decrypt**
  - 参数：

    ```js
    window.href = `nostrsigner:${encryptedText}?pubkey=${hex_pub_key}&compressionType=none&returnType=signature&type=nip44_decrypt&callbackUrl=https://example.com/?event=`;
    ```

- **decrypt_zap_event**
  - 参数：

    ```js
    window.href = `nostrsigner:${eventJson}?compressionType=none&returnType=signature&type=decrypt_zap_event&callbackUrl=https://example.com/?event=`;
    ```

### 示例

```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>测试</h1>

    <script>
        window.onload = function() {
            var url = new URL(window.location.href);
            var params = url.searchParams;
            if (params) {
                var param1 = params.get("event");
                if (param1) alert(param1)
            }
            let json = {
                kind: 1,
                content: "test"
            }
            let encodedJson = encodeURIComponent(JSON.stringify(json))
            var newAnchor = document.createElement("a");
            newAnchor.href = `nostrsigner:${encodedJson}?compressionType=none&returnType=signature&type=sign_event&callbackUrl=https://example.com/?event=`;
            newAnchor.textContent = "打开外部签名器";
            document.body.appendChild(newAnchor)
        }
    </script>
</body>
</html>
```
