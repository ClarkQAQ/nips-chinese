> __警告__  `不推荐`: 已被 [NIP-17](17_ZH.md) 取代

NIP-04
======

加密直接消息
------------------------

`最终` `不推荐` `可选`

一个种类为 `4` 的特殊事件，意为"加密直接消息"。它应该具有以下属性：

**`content`** 必须等于用户想要写入的任何内容的 base64 编码、aes-256-cbc 加密字符串，使用通过将接收者的公钥与发送者的私钥结合生成的共享密码进行加密；然后附加 base64 编码的初始化向量，就像它是一个名为"iv"的查询字符串参数一样。格式如下：`"content": "<encrypted_text>?iv=<initialization_vector>"`。

**`tags`** 必须包含一个标识消息接收者的条目（这样中继器可以自然地将此事件转发给他们），格式为 `["p", "<公钥，作为十六进制字符串>"]`。

**`tags`** 可能包含一个标识对话中的上一条消息或我们明确回复的消息的条目（这样可以进行上下文化、更有组织的对话），格式为 `["e", "<事件ID>"]`。

**注意**：默认情况下，在 [libsecp256k1](https://github.com/bitcoin-core/secp256k1) ECDH 实现中，密钥是共享点的 SHA256 哈希（X 和 Y 坐标）。在 Nostr 中，只有共享点的 X 坐标用作密钥，并且不进行哈希。如果使用 libsecp256k1，必须将复制 X 坐标的自定义函数作为 `hashfp` 参数传递给 `secp256k1_ecdh`。参见[这里](https://github.com/bitcoin-core/secp256k1/blob/master/src/modules/ecdh/main_impl.h#L29)。

在 JavaScript 中生成此类事件的代码示例：

```js
import crypto from 'crypto'
import * as secp from '@noble/secp256k1'

let sharedPoint = secp.getSharedSecret(ourPrivateKey, '02' + theirPublicKey)
let sharedX = sharedPoint.slice(1, 33)

let iv = crypto.randomFillSync(new Uint8Array(16))
var cipher = crypto.createCipheriv(
  'aes-256-cbc',
  Buffer.from(sharedX),
  iv
)
let encryptedMessage = cipher.update(text, 'utf8', 'base64')
encryptedMessage += cipher.final('base64')
let ivBase64 = Buffer.from(iv.buffer).toString('base64')

let event = {
  pubkey: ourPubKey,
  created_at: Math.floor(Date.now() / 1000),
  kind: 4,
  tags: [['p', theirPublicKey]],
  content: encryptedMessage + '?iv=' + ivBase64
}
```

## 安全警告

此标准远未达到对等加密通信的最新技术水平，并且在事件中泄露元数据，因此不得用于任何真正需要保密的内容，并且只能与使用 `AUTH` 限制谁可以获取您的 `kind:4` 事件的中继器一起使用。

## 客户端实现警告

客户端*不应该*从 `.content` 中搜索和替换公钥或笔记引用。如果像常规文本笔记一样处理（其中 `@npub...` 被替换为带有 `["p", "..."]` 标签的 `#[0]`），标签会泄露，被提及的用户将在其收件箱中收到消息。
