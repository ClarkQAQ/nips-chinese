NIP-44
======

加密载荷（版本化）
------------------------------

`可选`

本 NIP 引入了一种基于密钥对加密的新数据格式。本 NIP 是版本化的，允许多种算法选择同时存在。此格式可用于许多用途，但必须在 NIP-01 中描述的签名事件的上下文中使用。

*注意*：此格式不定义与新的直接消息标准相关的任何 `kind`，只定义了定义一个所需的加密。它不应用作 NIP-04 载荷的直接替代品。

## 版本

当前定义的加密算法：

- `0x00` - 保留
- `0x01` - 已弃用且未定义
- `0x02` - secp256k1 ECDH, HKDF, 填充, ChaCha20, HMAC-SHA256, base64

## 限制

每个 nostr 用户都有自己的公钥，这解决了其他解决方案中存在的密钥分发问题。然而，nostr 基于中继器的架构使得实现更强大的私人消息协议变得困难，这些协议具有元数据隐藏、前向保密和后妥协安全性等功能。

本 NIP 的目标是有一种_简单_的方法来加密在签名事件上下文中使用的载荷。当将此 NIP 应用于任何用例时，重要的是要记住您的用户威胁模型和此 NIP 的限制。对于高风险情况，用户应该在专门的 E2EE 消息软件中聊天，并限制 nostr 的使用仅用于交换联系人。

单独来看，使用此方案发送的消息有许多重要的缺点：

- 无可否认性：可以证明事件是由特定密钥签名的
- 无前向保密：当密钥被泄露时，可以解密所有以前的对话
- 无后妥协安全性：当密钥被泄露时，可以解密所有未来的对话
- 无后量子安全性：强大的量子计算机将能够解密消息
- IP 地址泄露：用户 IP 可能被中继器和用户与中继器之间的所有中介看到
- 日期泄露：`created_at` 是公开的，因为它是 NIP-01 事件的一部分
- 有限的消息大小泄露：填充只能部分掩盖真实消息长度
- 无附件：不支持附件

缺乏前向保密可以通过仅向受信任的中继器发送消息，并要求中继器在经过一定持续时间后删除存储的消息来部分缓解。

## 版本 2

NIP-44 版本 2 具有以下设计特征：

- 载荷在签名之前而不是之后使用 MAC 进行身份验证，因为事件被假定按照 NIP-01 中的指定进行签名。外部签名用于验证完整载荷，并且必须在解密之前验证。
- 使用 ChaCha 而不是 AES，因为它更快并且对多密钥攻击有[更好的安全性](https://datatracker.ietf.org/doc/draft-irtf-cfrg-aead-limits/)。
- 使用 ChaCha 而不是 XChaCha，因为 XChaCha 尚未标准化。此外，xChaCha 改进的随机数碰撞阻力并不必要，因为每条消息都有一个新的（密钥，随机数）对。
- 使用 HMAC-SHA256 而不是 Poly1305，因为多项式 MAC 更容易伪造。
- 使用 SHA256 而不是 SHA3 或 BLAKE，因为它已经在 nostr 中使用。此外，BLAKE 的速度优势在非并行环境中较小。
- 使用自定义填充方案而不是 padmé，因为它为小消息提供更好的泄露减少。
- 使用 Base64 编码而不是另一种编码算法，因为它广泛可用，并且已经在 nostr 中使用。

### 加密

1. 计算对话密钥
   - 执行公钥 B 乘以私钥 A 的 ECDH（标量乘法）
     输出 `shared_x` 必须是未哈希的、32 字节编码的共享点的 x 坐标
   - 使用 HKDF-extract 与 sha256，`IKM=shared_x` 和 `salt=utf8_encode('nip44-v2')`
   - HKDF 输出将是两个用户之间的 `conversation_key`。
   - 当密钥角色交换时，它总是相同的：`conv(a, B) == conv(b, A)`
2. 生成随机 32 字节随机数
   - 始终使用 [CSPRNG](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator)
   - 不要从消息内容生成随机数
   - 不要在消息之间重复使用相同的随机数：这样做会使它们可解密，但不会泄露长期密钥
3. 计算消息密钥
   - 密钥从 `conversation_key` 和 `nonce` 生成。验证两者都是 32 字节长
   - 使用 HKDF-expand，与 sha256，`PRK=conversation_key`，`info=nonce` 和 `L=76`
   - 将 76 字节 HKDF 输出切片为：`chacha_key`（字节 0..32），`chacha_nonce`（字节 32..44），`hmac_key`（字节 44..76）
4. 添加填充
   - 内容必须从 UTF-8 编码为字节数组
   - 验证明文长度。最小值是 1 字节，最大值是 65535 字节
   - 填充格式是：`[plaintext_length: u16][plaintext][zero_bytes]`
   - 填充算法与二的幂相关，最小填充消息大小为 32 字节
   - 明文长度作为填充块的前 2 字节以大端序编码
5. 加密填充内容
   - 使用 ChaCha20，使用步骤 3 中的密钥和随机数
6. 计算 MAC（消息身份验证码）
   - 使用 AAD（附加身份验证数据）- 而不是在密文上计算 MAC，它在 `nonce` 和 `ciphertext` 的连接上计算
   - 验证 AAD（随机数）是 32 字节
7. 使用 `concat(version, nonce, ciphertext, mac)` 进行 Base64 编码（带填充）参数

加密载荷必须包含在事件的载荷中，进行哈希，并按照 NIP 01 中定义的使用 secp256k1 上的 schnorr 签名方案进行签名。

### 解密

在解密之前，事件的公钥和签名必须按照 NIP 01 中定义的进行验证。公钥必须是有效的非零 secp256k1 曲线点，签名必须是有效的 secp256k1 schnorr 签名。有关确切的验证规则，请参考 BIP-340。

1. 检查第一个载荷字符是否为 `#`
   - `#` 是一个可选的面向未来的标志，意味着使用非 base64 编码
   - `#` 不存在于 base64 字母表中，但是，实现必须指示加密版本尚未支持，而不是抛出 `base64 is invalid`
2. 解码 base64
   - Base64 解码为 `version, nonce, ciphertext, mac`
   - 如果版本未知，实现必须指示加密版本不受支持
   - 验证 base64 消息长度以防止对 base64 解码器的 DoS：它可以在 132 到 87472 字符的范围内
   - 验证解码消息长度以验证解码器的输出：它可以在 99 到 65603 字节的范围内
3. 计算对话密钥
   - 参见[加密](#加密)的步骤 1
4. 计算消息密钥
   - 参见[加密](#加密)的步骤 3
5. 使用 AAD 计算 MAC（消息身份验证码）并比较
   - 如果 MAC 与步骤 2 中解码的 MAC 不匹配，停止并抛出错误
   - 使用恒定时间比较算法
6. 解密密文
   - 使用步骤 3 中的密钥和随机数使用 ChaCha20
7. 移除填充
   - 读取明文的前两个 BE 字节，对应明文长度
   - 验证切片明文的长度与两个 BE 字节的值匹配
   - 验证从[加密](#加密)过程步骤 3 计算的填充与实际填充匹配

### 详细信息

- 加密方法
  - `secure_random_bytes(length)` 从 CSPRNG 获取随机性。
  - `hkdf(IKM, salt, info, L)` 表示使用 SHA256 哈希函数的 HKDF [(RFC 5869)](https://datatracker.ietf.org/doc/html/rfc5869)，包括方法 `hkdf_extract(IKM, salt)` 和 `hkdf_expand(OKM, info, L)`。
  - `chacha20(key, nonce, data)` 是 ChaCha20 [(RFC 8439)](https://datatracker.ietf.org/doc/html/rfc8439)，起始计数器设置为 0。
  - `hmac_sha256(key, message)` 是 HMAC [(RFC 2104)](https://datatracker.ietf.org/doc/html/rfc2104)。
  - `secp256k1_ecdh(priv_a, pub_b)` 是点 B 乘以标量 a（`a ⋅ B`），在 [BIP340](https://github.com/bitcoin/bips/blob/e918b50731397872ad2922a1b08a5a4cd1d6d546/bip-0340.mediawiki) 中定义。操作产生共享点，我们使用 BIP340 中的方法 `bytes(P)` 编码共享点的 32 字节 x 坐标。私钥和公钥必须按照 BIP340 验证：公钥必须是有效的曲线上点，私钥必须是范围 `[1, secp256k1_order - 1]` 内的标量。NIP44 不对输出进行哈希：请记住这一点，因为一些库使用 sha256 对其进行哈希。例如，在 libsecp256k1 中，未哈希版本在 `secp256k1_ec_pubkey_tweak_mul` 中可用
- 运算符
  - `x[i:j]`，其中 `x` 是字节数组，`i, j <= 0` 返回一个 `(j - i)` 字节数组，包含 `x` 的第 `i` 字节（包含）到第 `j` 字节（不包含）的副本。
- 常量 `c`：
  - `min_plaintext_size` 是 1。1 字节消息填充到 32 字节。
  - `max_plaintext_size` 是 65535（64kB - 1）。它填充到 65536 字节。
- 函数
  - `base64_encode(string)` 和 `base64_decode(bytes)` 是 Base64（[RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648)，带填充）
  - `concat` 指字节数组连接
  - `is_equal_ct(a, b)` 是 2 个字节数组的恒定时间相等检查
  - `utf8_encode(string)` 和 `utf8_decode(bytes)` 将字符串转换为字节数组并返回
  - `write_u8(number)` 将数字限制为值 0..255 并编码为大端 uint8 字节数组
  - `write_u16_be(number)` 将数字限制为值 0..65535 并编码为大端 uint16 字节数组
  - `zeros(length)` 创建长度为 `length >= 0` 的字节数组，用零填充
  - `floor(number)` 和 `log2(number)` 是众所周知的数学方法

### 实现伪代码

以下是实现上述原语的类似 python 的伪代码函数集合，旨在指导实现者。不同语言的实现集合可在 https://github.com/paulmillr/nip44 获得。

```py
# 计算填充字节数组的长度。
def calc_padded_len(unpadded_len):
  next_power = 1 << (floor(log2(unpadded_len - 1))) + 1
  if next_power <= 256:
    chunk = 32
  else:
    chunk = next_power / 8
  if unpadded_len <= 32:
    return 32
  else:
    return chunk * (floor((len - 1) / chunk) + 1)

# 将未填充的明文转换为填充的字节数组
def pad(plaintext):
  unpadded = utf8_encode(plaintext)
  unpadded_len = len(plaintext)
  if (unpadded_len < c.min_plaintext_size or
      unpadded_len > c.max_plaintext_size): raise Exception('invalid plaintext length')
  prefix = write_u16_be(unpadded_len)
  suffix = zeros(calc_padded_len(unpadded_len) - unpadded_len)
  return concat(prefix, unpadded, suffix)

# 将填充的字节数组转换为未填充的明文
def unpad(padded):
  unpadded_len = read_uint16_be(padded[0:2])
  unpadded = padded[2:2+unpadded_len]
  if (unpadded_len == 0 or
      len(unpadded) != unpadded_len or
      len(padded) != 2 + calc_padded_len(unpadded_len)): raise Exception('invalid padding')
  return utf8_decode(unpadded)

# 元数据：始终 65b（版本：1b，随机数：32b，最大：32b）
# 明文：1b 到 0xffff
# 填充明文：32b 到 0xffff
# 密文：32b+2 到 0xffff+2
# 原始载荷：99（65+32+2）到 65603（65+0xffff+2）
# 压缩载荷（base64）：132b 到 87472b
def decode_payload(payload):
  plen = len(payload)
  if plen == 0 or payload[0] == '#': raise Exception('unknown version')
  if plen < 132 or plen > 87472: raise Exception('invalid payload size')
  data = base64_decode(payload)
  dlen = len(d)
  if dlen < 99 or dlen > 65603: raise Exception('invalid data size');
  vers = data[0]
  if vers != 2: raise Exception('unknown version ' + vers)
  nonce = data[1:33]
  ciphertext = data[33:dlen - 32]
  mac = data[dlen - 32:dlen]
  return (nonce, ciphertext, mac)

def hmac_aad(key, message, aad):
  if len(aad) != 32: raise Exception('AAD associated data must be 32 bytes');
  return hmac(sha256, key, concat(aad, message));

# 计算用户 A 和 B 之间的长期密钥：`get_key(Apriv, Bpub) == get_key(Bpriv, Apub)`
def get_conversation_key(private_key_a, public_key_b):
  shared_x = secp256k1_ecdh(private_key_a, public_key_b)
  return hkdf_extract(IKM=shared_x, salt=utf8_encode('nip44-v2'))

# 计算唯一的每条消息密钥
def get_message_keys(conversation_key, nonce):
  if len(conversation_key) != 32: raise Exception('invalid conversation_key length')
  if len(nonce) != 32: raise Exception('invalid nonce length')
  keys = hkdf_expand(OKM=conversation_key, info=nonce, L=76)
  chacha_key = keys[0:32]
  chacha_nonce = keys[32:44]
  hmac_key = keys[44:76]
  return (chacha_key, chacha_nonce, hmac_key)

def encrypt(plaintext, conversation_key, nonce):
  (chacha_key, chacha_nonce, hmac_key) = get_message_keys(conversation_key, nonce)
  padded = pad(plaintext)
  ciphertext = chacha20(key=chacha_key, nonce=chacha_nonce, data=padded)
  mac = hmac_aad(key=hmac_key, message=ciphertext, aad=nonce)
  return base64_encode(concat(write_u8(2), nonce, ciphertext, mac))

def decrypt(payload, conversation_key):
  (nonce, ciphertext, mac) = decode_payload(payload)
  (chacha_key, chacha_nonce, hmac_key) = get_message_keys(conversation_key, nonce)
  calculated_mac = hmac_aad(key=hmac_key, message=ciphertext, aad=nonce)
  if not is_equal_ct(calculated_mac, mac): raise Exception('invalid MAC')
  padded_plaintext = chacha20(key=chacha_key, nonce=chacha_nonce, data=ciphertext)
  return unpad(padded_plaintext)

# 用法：
#   conversation_key = get_conversation_key(sender_privkey, recipient_pubkey)
#   nonce = secure_random_bytes(32)
#   payload = encrypt('hello world', conversation_key, nonce)
#   'hello world' == decrypt(payload, conversation_key)
```

### 审计

该标准的 v2 版本于 2023 年 12 月由 [Cure53](https://cure53.de) 审计。
查看 [audit-2023.12.pdf](https://github.com/paulmillr/nip44/blob/ce63c2eaf345e9f7f93b48f829e6bdeb7e7d7964/audit-2023.12.pdf) 和[审计师网站](https://cure53.de/audit-report_nip44-implementations.pdf)。

### 测试和代码

不同语言的实现集合可在 https://github.com/paulmillr/nip44 获得。

我们发布了广泛的测试向量。我们没有直接在文档中包含它，而是提供了向量的 sha256 校验和：

    269ed0f69e4c192512cc779e78c555090cebc7c785b609e338a62afc3ce25040  nip44.vectors.json

文件中测试向量的示例：

```json
{
  "sec1": "0000000000000000000000000000000000000000000000000000000000000001",
  "sec2": "0000000000000000000000000000000000000000000000000000000000000002",
  "conversation_key": "c41c775356fd92eadc63ff5a0dc1da211b268cbea22316767095b2871ea1412d",
  "nonce": "0000000000000000000000000000000000000000000000000000000000000001",
  "plaintext": "a",
  "payload": "AgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABee0G5VSK0/9YypIObAtDKfYEAjD35uVkHyB0F4DwrcNaCXlCWZKaArsGrY6M9wnuTMxWfp1RTN9Xga8no+kF5Vsb"
}
```

文件还包含中间值。关于其使用的快速指导：

- `valid.get_conversation_key`：从密钥 sec1 和公钥 pub2 计算 conversation_key
- `valid.get_message_keys`：从 conversation_key 和 nonce 计算 chacha_key、chacha_nonce、hmac_key
- `valid.calc_padded_len`：取未填充长度（第一个值），计算填充长度（第二个值）
- `valid.encrypt_decrypt`：模拟真实对话。从 sec2 计算 pub2，从（sec1，pub2）验证 conversation_key，加密，验证载荷，然后从 sec1 计算 pub1，从（sec2，pub1）验证 conversation_key，解密，验证明文。
- `valid.encrypt_decrypt_long_msg`：与前一步相同，但不是完整的明文和载荷，而是提供它们的校验和。
- `invalid.encrypt_msg_lengths`
- `invalid.get_conversation_key`：计算 conversation_key 必须抛出错误
- `invalid.decrypt`：解密消息内容必须抛出错误
