NIP-59
======

礼品包装
---------

`可选`

本 NIP 定义了封装任何 nostr 事件的协议。这使得可以隐藏给定事件的大部分元数据，执行协作签名等等。

本 NIP *不* 定义任何消息协议。本 NIP 的应用应单独定义。

本 NIP 依赖于 [NIP-44](./44_ZH.md) 的版本化加密算法。

## 概述

此协议使用三个主要概念来保护目标事件的传输：`rumor`、`seal` 和 `gift wrap`。

- `rumor` 是常规 nostr 事件，但**未签名**。这意味着如果它泄露，就无法验证。
- `rumor` 被序列化为 JSON，加密，并放置在 `seal` 的 `content` 字段中。然后 `seal` 由笔记作者签名。`seal` 上唯一公开可用的信息是谁签署了它，但不是说了什么。
- `seal` 被序列化为 JSON，加密，并放置在 `gift wrap` 的 `content` 字段中。

这允许跨层隔离关注点：

- rumor 携带内容但未签名，这意味着如果泄露，它将被中继器和客户端拒绝，并且无法验证。这提供了一定程度的可否认性。
- seal 识别作者而不透露内容或收件人。
- gift wrap 可以添加元数据（收件人、标签、不同作者）而不透露真实作者。

## 协议描述

### 1. Rumor 事件种类

`rumor` 与未签名事件相同。任何事件种类都可以通过删除签名成为 `rumor`。

### 2. Seal 事件种类

`seal` 是 `kind:13` 事件，用发送者的常规密钥包装 `rumor`。`seal` **总是** 加密到接收者的公钥，但没有指向接收者的 `p` 标签。没有接收者或发送者的私钥，无法知道 rumor 是给谁的。此事件中唯一的公开信息是谁在签署它。

```json
{
  "id": "<id>",
  "pubkey": "<真实作者的公钥>",
  "content": "<加密的 rumor>",
  "kind": 13,
  "created_at": 1686840217,
  "tags": [],
  "sig": "<真实作者的公钥签名>"
}
```

`kind:13` 中的标签必须始终为空。内部事件必须始终未签名。

### 3. Gift Wrap 事件种类

`gift wrap` 事件是包装任何其他事件的 `kind:1059` 事件。`tags` 应该包含将事件路由到其预期收件人所需的任何信息，包括收件人的 `p` 标签或 [NIP-13](13_ZH.md) 工作量证明。

```json
{
  "id": "<id>",
  "pubkey": "<随机、一次性使用公钥>",
  "content": "<加密的 kind 13>",
  "kind": 1059,
  "created_at": 1686840217,
  "tags": [["p", "<收件人公钥>"]],
  "sig": "<随机、一次性使用公钥签名>"
}
```

## 加密载荷

按照 [NIP-44](44_ZH.md) 对 JSON 编码的事件进行加密。将加密载荷放置在包装器事件（`seal` 或 `gift wrap`）的 `.content` 中。

## 其他考虑

如果 `rumor` 针对多个方，或者如果作者想要保留加密副本，可以为每个收件人单独包装和寻址单个 `rumor`。

规范的 `created_at` 时间属于 `rumor`。所有其他时间戳应该调整以阻止时间分析攻击。请注意，一些中继器不提供未来日期的事件，因此所有时间戳都应该在过去。

中继器可能选择不存储礼品包装事件，因为它们对公众没有用处。客户端可能选择根据 [NIP-13](13_ZH.md) 为包装器事件附加一定数量的工作量证明，以证明事件不是垃圾邮件或拒绝服务攻击。

为了保护收件人元数据，中继器应该基于用户 AUTH 守护对 `kind 1059` 事件的访问。如果可能，客户端应该只向提供此保护的中继器发送包装事件。

为了保护收件人元数据，中继器应该只为标记的收件人提供 `kind 1059` 事件。如果可能，客户端应该只向实现 AUTH 的收件人的 `read` 中继器发送包装事件，并拒绝向非收件人提供包装事件。

## 示例

让我们在两方之间发送包装的 `kind 1` 消息，询问"你今晚要去聚会吗？"

- 作者私钥：`0beebd062ec8735f4243466049d7747ef5d6594ee838de147f8aab842b15e273`
- 收件人私钥：`e108399bd8424357a710b606ae0c13166d853d327e47a6e5e038197346bdbf45`
- 临时包装器密钥：`4f02eac59266002db5801adc5270700ca69d5b8f761d8732fab2fbf233c90cbd`

请注意，此消息协议不应在实践中使用，这只是一个示例。有关依赖礼品包装的具体消息协议，请参考其他 NIP。

### 1. 创建事件

创建带有消息、接收者和您想要的任何其他标签的 `kind 1` 事件，由作者签名。
不要签署事件。

```json
{
  "created_at": 1691518405,
  "content": "你今晚要去聚会吗？",
  "tags": [],
  "kind": 1,
  "pubkey": "611df01bfcf85c26ae65453b772d8f1dfd25c264621c0277e1fc1518686faef9",
  "id": "9dd003c6d3b73b74a85a9ab099469ce251653a7af76f523671ab828acd2a0ef9"
}
```

### 2. 密封 rumor

使用作者私钥和收件人公钥派生的对话密钥加密 JSON 编码的 `rumor`。将结果放在 `kind 13` `seal` 事件的 `content` 字段中。用作者的密钥签署它。

```json
{
  "content": "AqBCdwoS7/tPK+QGkPCadJTn8FxGkd24iApo3BR9/M0uw6n4RFAFSPAKKMgkzVMoRyR3ZS/aqATDFvoZJOkE9cPG/TAzmyZvr/WUIS8kLmuI1dCA+itFF6+ULZqbkWS0YcVU0j6UDvMBvVlGTzHz+UHzWYJLUq2LnlynJtFap5k8560+tBGtxi9Gx2NIycKgbOUv0gEqhfVzAwvg1IhTltfSwOeZXvDvd40rozONRxwq8hjKy+4DbfrO0iRtlT7G/eVEO9aJJnqagomFSkqCscttf/o6VeT2+A9JhcSxLmjcKFG3FEK3Try/WkarJa1jM3lMRQqVOZrzHAaLFW/5sXano6DqqC5ERD6CcVVsrny0tYN4iHHB8BHJ9zvjff0NjLGG/v5Wsy31+BwZA8cUlfAZ0f5EYRo9/vKSd8TV0wRb9DQ=",
  "kind": 13,
  "created_at": 1703015180,
  "pubkey": "611df01bfcf85c26ae65453b772d8f1dfd25c264621c0277e1fc1518686faef9",
  "tags": [],
  "id": "28a87d7c074d94a58e9e89bb3e9e4e813e2189f285d797b1c56069d36f59eaa7",
  "sig": "02fc3facf6621196c32912b1ef53bac8f8bfe9db51c0e7102c073103586b0d29c3f39bdaa1e62856c20e90b6c7cc5dc34ca8bb6a528872cf6e65e6284519ad73"
}
```

### 3. 包装 seal

使用您的临时、一次性随机密钥加密 JSON 编码的 `kind 13` 事件。将结果放在 `kind 1059` 的 `content` 字段中。添加包含收件人公钥的单个 `p` 标签。使用上一步生成的随机密钥签署 `gift wrap`。

```json
{
  "content": "AhC3Qj/QsKJFWuf6xroiYip+2yK95qPwJjVvFujhzSguJWb/6TlPpBW0CGFwfufCs2Zyb0JeuLmZhNlnqecAAalC4ZCugB+I9ViA5pxLyFfQjs1lcE6KdX3euCHBLAnE9GL/+IzdV9vZnfJH6atVjvBkNPNzxU+OLCHO/DAPmzmMVx0SR63frRTCz6Cuth40D+VzluKu1/Fg2Q1LSst65DE7o2efTtZ4Z9j15rQAOZfE9jwMCQZt27rBBK3yVwqVEriFpg2mHXc1DDwHhDADO8eiyOTWF1ghDds/DxhMcjkIi/o+FS3gG1dG7gJHu3KkGK5UXpmgyFKt+421m5o++RMD/BylS3iazS1S93IzTLeGfMCk+7IKxuSCO06k1+DaasJJe8RE4/rmismUvwrHu/HDutZWkvOAhd4z4khZo7bJLtiCzZCZ74lZcjOB4CYtuAX2ZGpc4I1iOKkvwTuQy9BWYpkzGg3ZoSWRD6ty7U+KN+fTTmIS4CelhBTT15QVqD02JxfLF7nA6sg3UlYgtiGw61oH68lSbx16P3vwSeQQpEB5JbhofW7t9TLZIbIW/ODnI4hpwj8didtk7IMBI3Ra3uUP7ya6vptkd9TwQkd/7cOFaSJmU+BIsLpOXbirJACMn+URoDXhuEtiO6xirNtrPN8jYqpwvMUm5lMMVzGT3kMMVNBqgbj8Ln8VmqouK0DR+gRyNb8fHT0BFPwsHxDskFk5yhe5c/2VUUoKCGe0kfCcX/EsHbJLUUtlHXmTqaOJpmQnW1tZ/siPwKRl6oEsIJWTUYxPQmrM2fUpYZCuAo/29lTLHiHMlTbarFOd6J/ybIbICy2gRRH/LFSryty3Cnf6aae+A9uizFBUdCwTwffc3vCBae802+R92OL78bbqHKPbSZOXNC+6ybqziezwG+OPWHx1Qk39RYaF0aFsM4uZWrFic97WwVrH5i+/Nsf/OtwWiuH0gV/SqvN1hnkxCTF/+XNn/laWKmS3e7wFzBsG8+qwqwmO9aVbDVMhOmeUXRMkxcj4QreQkHxLkCx97euZpC7xhvYnCHarHTDeD6nVK+xzbPNtzeGzNpYoiMqxZ9bBJwMaHnEoI944Vxoodf51cMIIwpTmmRvAzI1QgrfnOLOUS7uUjQ/IZ1Qa3lY08Nqm9MAGxZ2Ou6R0/Z5z30ha/Q71q6meAs3uHQcpSuRaQeV29IASmye2A2Nif+lmbhV7w8hjFYoaLCRsdchiVyNjOEM4VmxUhX4VEvw6KoCAZ/XvO2eBF/SyNU3Of4SO",
  "kind": 1059,
  "created_at": 1703021488,
  "pubkey": "18b1a75918f1f2c90c23da616bce317d36e348bcf5f7ba55e75949319210c87c",
  "id": "5c005f3ccf01950aa8d131203248544fb1e41a0d698e846bd419cec3890903ac",
  "sig": "35fabdae4634eb630880a1896a886e40fd6ea8a60958e30b89b33a93e6235df750097b04f9e13053764251b8bc5dd7e8e0794a3426a90b6bcc7e5ff660f54259",
  "tags": [["p", "166bf3765ebd1fc55decfe395beff2ea3b2a4e0a8946e7eb578512b555737c99"]],
}
```

### 4. 选择性广播

仅向收件人的中继器广播 `kind 1059` 事件。删除所有其他事件。

## 代码示例

### JavaScript

```javascript
import {bytesToHex} from "@noble/hashes/utils"
import type {EventTemplate, UnsignedEvent, Event} from "nostr-tools"
import {getPublicKey, getEventHash, nip19, nip44, finalizeEvent, generateSecretKey} from "nostr-tools"

type Rumor = UnsignedEvent & {id: string}

const TWO_DAYS = 2 * 24 * 60 * 60

const now = () => Math.round(Date.now() / 1000)
const randomNow = () => Math.round(now() - (Math.random() * TWO_DAYS))

const nip44ConversationKey = (privateKey: Uint8Array, publicKey: string) =>
  nip44.v2.utils.getConversationKey(bytesToHex(privateKey), publicKey)

const nip44Encrypt = (data: EventTemplate, privateKey: Uint8Array, publicKey: string) =>
  nip44.v2.encrypt(JSON.stringify(data), nip44ConversationKey(privateKey, publicKey))

const nip44Decrypt = (data: Event, privateKey: Uint8Array) =>
  JSON.parse(nip44.v2.decrypt(data.content, nip44ConversationKey(privateKey, data.pubkey)))

const createRumor = (event: Partial<UnsignedEvent>, privateKey: Uint8Array) => {
  const rumor = {
    created_at: now(),
    content: "",
    tags: [],
    ...event,
    pubkey: getPublicKey(privateKey),
  } as any

  rumor.id = getEventHash(rumor)

  return rumor as Rumor
}

const createSeal = (rumor: Rumor, privateKey: Uint8Array, recipientPublicKey: string) => {
  return finalizeEvent(
    {
      kind: 13,
      content: nip44Encrypt(rumor, privateKey, recipientPublicKey),
      created_at: randomNow(),
      tags: [],
    },
    privateKey
  ) as Event
}

const createWrap = (event: Event, recipientPublicKey: string) => {
  const randomKey = generateSecretKey()

  return finalizeEvent(
    {
      kind: 1059,
      content: nip44Encrypt(event, randomKey, recipientPublicKey),
      created_at: randomNow(),
      tags: [["p", recipientPublicKey]],
    },
    randomKey
  ) as Event
}

// 使用上面示例的测试用例
const senderPrivateKey = nip19.decode(`nsec1p0ht6p3wepe47sjrgesyn4m50m6avk2waqudu9rl324cg2c4ufesyp6rdg`).data
const recipientPrivateKey = nip19.decode(`nsec1uyyrnx7cgfp40fcskcr2urqnzekc20fj0er6de0q8qvhx34ahazsvs9p36`).data
const recipientPublicKey = getPublicKey(recipientPrivateKey)

const rumor = createRumor(
  {
    kind: 1,
    content: "你今晚要去聚会吗？",
  },
  senderPrivateKey
)

const seal = createSeal(rumor, senderPrivateKey, recipientPublicKey)
const wrap = createWrap(seal, recipientPublicKey)

// 收件人用他们的私钥解包。

const unwrappedSeal = nip44Decrypt(wrap, recipientPrivateKey)
const unsealedRumor = nip44Decrypt(unwrappedSeal, recipientPrivateKey)
```
