NIP-01
======

基本协议流程描述
-------------------------------

`草案` `必需`

本 NIP 定义了每个人都应该实现的基本协议。新的 NIP 可能会向这里描述的结构和流程添加新的可选（或必需）字段、消息和功能。

## 事件和签名

每个用户都有一个密钥对。签名、公钥和编码按照 [曲线 `secp256k1` 的 Schnorr 签名标准](https://bips.xyz/340) 进行。

唯一存在的对象类型是 `event`（事件），它在网络上的格式如下：

```yaml
{
  "id": <序列化事件数据的 32 字节小写十六进制编码 sha256>,
  "pubkey": <事件创建者的 32 字节小写十六进制编码公钥>,
  "created_at": <以秒为单位的 Unix 时间戳>,
  "kind": <0 到 65535 之间的整数>,
  "tags": [
    [<任意字符串>...],
    // ...
  ],
  "content": <任意字符串>,
  "sig": <序列化事件数据的 sha256 哈希签名的 64 字节小写十六进制，与 "id" 字段相同>
}
```

要获取 `event.id`，我们对序列化事件进行 `sha256` 哈希。序列化是对以下结构的 UTF-8 JSON 序列化字符串（如下所述）进行的：

```
[
  0,
  <公钥，作为小写十六进制字符串>,
  <created_at，作为数字>,
  <种类，作为数字>,
  <标签，作为非空字符串数组的数组>,
  <内容，作为字符串>
]
```

为了防止实现差异为同一事件创建不同的事件 ID，在序列化时必须遵循以下规则：
- 应使用 UTF-8 进行编码。
- 输出 JSON 中不应包含空白、换行或其他不必要的格式。
- 内容字段中的以下字符必须按所示方式转义，所有其他字符必须逐字包含：
  - 换行符（`0x0A`），使用 `\n`
  - 双引号（`0x22`），使用 `\"`
  - 反斜杠（`0x5C`），使用 `\\`
  - 回车符（`0x0D`），使用 `\r`
  - 制表符（`0x09`），使用 `\t`
  - 退格符（`0x08`），使用 `\b`
  - 换页符（`0x0C`），使用 `\f`

### 标签

每个标签都是一个或多个字符串的数组，围绕它们有一些约定。看看下面的例子：

```jsonc
{
  "tags": [
    ["e", "5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36", "wss://nostr.example.com"],
    ["p", "f7234bd4c1394dda46d09f35bd384dd30cc552ad5541990f98844fb06676e9ca"],
    ["a", "30023:f7234bd4c1394dda46d09f35bd384dd30cc552ad5541990f98844fb06676e9ca:abcd", "wss://nostr.example.com"],
    ["alt", "reply"],
    // ...
  ],
  // ...
}
```

标签数组的第一个元素称为标签 _名称_ 或 _键_，第二个元素称为标签 _值_。因此我们可以安全地说上述事件有一个设置为 `"5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"` 的 `e` 标签，一个设置为 `"reply"` 的 `alt` 标签，等等。第二个元素之后的所有元素没有常规名称。

本 NIP 定义了 3 个可以在所有事件种类中使用的标准标签，具有相同的含义。它们如下：

- `e` 标签，用于引用事件：`["e", <另一个事件 ID 的 32 字节小写十六进制>, <推荐的中继器 URL，可选>, <作者公钥的 32 字节小写十六进制，可选>]`
- `p` 标签，用于引用另一个用户：`["p", <公钥的 32 字节小写十六进制>, <推荐的中继器 URL，可选>]`
- `a` 标签，用于引用可寻址或可替换事件
    - 对于可寻址事件：`["a", "<种类整数>:<公钥的 32 字节小写十六进制>:<d 标签值>", <推荐的中继器 URL，可选>]`
    - 对于普通可替换事件：`["a", "<种类整数>:<公钥的 32 字节小写十六进制>:", <推荐的中继器 URL，可选>]`（注意：包含尾随冒号）

按照惯例，所有单字母（仅英文字母：a-z，A-Z）键标签都应该被中继器索引，这样就可以，例如，通过使用 `{"#e": ["5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"]}` 过滤器来查询或订阅引用事件 `"5c83da77af1dec6d7289834998ad7aafbd9e2191396d75ec3cc27f5a77226f36"` 的事件。只有任何给定标签中的第一个值会被索引。

### 种类

种类指定客户端应如何解释每个事件的含义以及每个事件的其他字段（例如，`"r"` 标签在种类 1 的事件中可能有一个含义，而在种类 10002 的事件中可能有完全不同的含义）。每个 NIP 可能定义一组在其他地方未定义的种类的含义。例如，[NIP-10](10.md) 为社交媒体应用程序指定了 `kind:1` 文本笔记。

本 NIP 定义了一个基本种类：

- `0`：**用户元数据**：`content` 设置为字符串化的 JSON 对象 `{name: <昵称或全名>, about: <简短介绍>, picture: <图像的 URL>}`，描述创建事件的用户。可以设置[额外的元数据字段](24.md#kind-0)。当中继器收到同一公钥的新事件时，可能会删除较旧的事件。

以及允许更容易实验和中继器实现灵活性的种类范围约定：

- 对于种类 `n`，其中 `1000 <= n < 10000 || 4 <= n < 45 || n == 1 || n == 2`，事件是**常规的**，这意味着中继器应该存储所有这些事件。
- 对于种类 `n`，其中 `10000 <= n < 20000 || n == 0 || n == 3`，事件是**可替换的**，这意味着对于 `pubkey` 和 `kind` 的每个组合，中继器必须只存储最新的事件，较旧的版本可以被丢弃。
- 对于种类 `n`，其中 `20000 <= n < 30000`，事件是**临时的**，这意味着中继器不应该存储它们。
- 对于种类 `n`，其中 `30000 <= n < 40000`，事件是**可寻址的**，通过它们的 `kind`、`pubkey` 和 `d` 标签值 —— 这意味着对于 `kind`、`pubkey` 和 `d` 标签值的每个组合，中继器必须只存储最新的事件，较旧的版本可以被丢弃。

对于具有相同时间戳的可替换事件，应保留具有最低 ID（按字典顺序排在第一位）的事件，丢弃其他事件。

当回答可替换事件的 `REQ` 消息时，如 `{"kinds":[0],"authors":[<hex-key>]}`，即使中继器存储了多个版本，它也应该只返回最新的版本。

这些只是约定，中继器实现可能有所不同。

## 客户端和中继器之间的通信

中继器暴露一个 WebSocket 端点，客户端可以连接到该端点。客户端应该打开到每个中继器的单个 WebSocket 连接，并将其用于所有订阅。中继器可能限制来自特定 IP/客户端等的连接数量。

### 从客户端到中继器：发送事件和创建订阅

客户端可以发送 3 种类型的消息，必须是 JSON 数组，按照以下模式：

  * `["EVENT", <如上定义的事件 JSON>]`，用于发布事件。
  * `["REQ", <subscription_id>, <filters1>, <filters2>, ...]`，用于请求事件并订阅新更新。
  * `["CLOSE", <subscription_id>]`，用于停止之前的订阅。

`<subscription_id>` 是一个任意的、非空的字符串，最大长度为 64 个字符。它表示每个连接的订阅。中继器必须为每个 WebSocket 连接独立管理 `<subscription_id>`。`<subscription_id>` 不保证全局唯一。

`<filtersX>` 是一个 JSON 对象，确定在该订阅中将发送哪些事件，它可以具有以下属性：

```yaml
{
  "ids": <事件 ID 列表>,
  "authors": <小写公钥列表，事件的公钥必须是其中之一>,
  "kinds": <种类编号列表>,
  "#<单字母 (a-zA-Z)>": <标签值列表，对于 #e — 事件 ID 列表，对于 #p — 公钥列表，等等>,
  "since": <整数 Unix 时间戳（秒）。事件必须有 created_at >= 此值才能通过>,
  "until": <整数 Unix 时间戳（秒）。事件必须有 created_at <= 此值才能通过>,
  "limit": <中继器在初始查询中应该返回的最大事件数>
}
```

收到 `REQ` 消息后，中继器应该返回匹配过滤器的事件。它接收的任何新事件应该发送到同一个 WebSocket，直到连接关闭、收到具有相同 `<subscription_id>` 的 `CLOSE` 事件，或使用相同的 `<subscription_id>` 发送新的 `REQ`（在这种情况下创建新订阅，替换旧订阅）。

包含列表的过滤器属性（`ids`、`authors`、`kinds` 和标签过滤器如 `#e`）是具有一个或多个值的 JSON 数组。数组值中至少有一个必须与事件中的相关字段匹配，条件才被认为匹配。对于标量事件属性如 `authors` 和 `kind`，事件中的属性必须包含在过滤器列表中。对于标签属性如 `#e`（事件可能有多个值），事件和过滤器条件值必须至少有一个共同项。

`ids`、`authors`、`#e` 和 `#p` 过滤器列表必须包含精确的 64 字符小写十六进制值。

`since` 和 `until` 属性可用于指定订阅中返回的事件时间范围。如果过滤器包含 `since` 属性，则 `created_at` 大于或等于 `since` 的事件被认为匹配过滤器。`until` 属性类似，除了 `created_at` 必须小于或等于 `until`。简而言之，如果 `since <= created_at <= until` 成立，则事件匹配过滤器。

过滤器的所有指定条件都必须匹配事件才能通过过滤器，即，多个条件被解释为 `&&` 条件。

`REQ` 消息可能包含多个过滤器。在这种情况下，匹配任何过滤器的事件都将被返回，即，多个过滤器被解释为 `||` 条件。

过滤器的 `limit` 属性仅对初始查询有效，之后必须被忽略。当存在 `limit: n` 时，假设初始查询中返回的事件将是按 `created_at` 排序的最后 `n` 个事件。较新的事件应该出现在前面，在平局的情况下，具有最低 ID（按字典顺序排在第一位）的事件应该在前面。中继器应该使用 `limit` 值来指导初始响应中返回多少事件。返回较少的事件是可以接受的，但应该避免返回（更多）事件以防止客户端过载。

### 从中继器到客户端：发送事件和通知

中继器可以发送 5 种类型的消息，也必须是 JSON 数组，按照以下模式：

  * `["EVENT", <subscription_id>, <如上定义的事件 JSON>]`，用于发送客户端请求的事件。
  * `["OK", <event_id>, <true|false>, <message>]`，用于指示接受或拒绝 `EVENT` 消息。
  * `["EOSE", <subscription_id>]`，用于指示 _存储事件结束_ 和实时接收新事件的开始。
  * `["CLOSED", <subscription_id>, <message>]`，用于指示订阅在服务器端结束。
  * `["NOTICE", <message>]`，用于向客户端发送人类可读的错误消息或其他内容。

本 NIP 没有定义如何发送或处理 `NOTICE` 消息的规则。

- `EVENT` 消息必须只与客户端之前发起的订阅相关的订阅 ID 一起发送（使用上面的 `REQ` 消息）。
- `OK` 消息必须响应从客户端收到的 `EVENT` 消息发送，当中继器接受事件时，第 3 个参数必须设置为 `true`，否则为 `false`。第 4 个参数必须始终存在，但当第 3 个参数为 `true` 时可以是空字符串，否则必须是由机器可读的单词前缀后跟 `:` 然后是人类可读消息组成的字符串。一些例子：
  * `["OK", "b1a649ebe8...", true, ""]`
  * `["OK", "b1a649ebe8...", true, "pow: difficulty 25>=24"]`
  * `["OK", "b1a649ebe8...", true, "duplicate: already have this event"]`
  * `["OK", "b1a649ebe8...", false, "blocked: you are banned from posting here"]`
  * `["OK", "b1a649ebe8...", false, "blocked: please register your pubkey at https://my-expensive-relay.example.com"]`
  * `["OK", "b1a649ebe8...", false, "rate-limited: slow down there chief"]`
  * `["OK", "b1a649ebe8...", false, "invalid: event creation date is too far off from the current time"]`
  * `["OK", "b1a649ebe8...", false, "pow: difficulty 26 is less than 30"]`
  * `["OK", "b1a649ebe8...", false, "restricted: not allowed to write."]`
  * `["OK", "b1a649ebe8...", false, "error: could not connect to the database"]`
  * `["OK", "b1a649ebe8...", false, "mute: no one was listening to your ephemeral event and it wasn't handled in any way, it was ignored"]`
- `CLOSED` 消息必须在中继器拒绝履行 `REQ` 时发送。当中继器决定在客户端断开连接或发送 `CLOSE` 之前终止订阅时，也可以发送此消息。此消息使用与 `OK` 消息相同的模式，带有机器可读前缀和人类可读消息。一些例子：
  * `["CLOSED", "sub1", "unsupported: filter contains unknown elements"]`
  * `["CLOSED", "sub1", "error: could not connect to the database"]`
  * `["CLOSED", "sub1", "error: shutting down idle subscription"]`
- `OK` 和 `CLOSED` 的标准化机器可读前缀包括：`duplicate`、`pow`、`blocked`、`rate-limited`、`invalid`、`restricted`、`mute` 和 `error`（当以上都不适用时）。
