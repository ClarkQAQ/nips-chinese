> __警告__  `不推荐`: 增加不必要的负担而收益甚微

NIP-26
=======

委托事件签名
-----------------------

`草案` `可选`

本 NIP 定义了如何委托事件，使它们可以由其他密钥对签名。

此提案的另一个应用是在与客户端交互时抽象"根"密钥对的使用。例如，用户可以为他们希望使用的每个客户端生成新的密钥对，并授权这些密钥对代表他们的根公钥生成事件，其中根密钥对存储在冷存储中。

#### 引入"delegation"标签

本 NIP 引入了一个新标签：`delegation`，格式如下：

```json
[
  "delegation",
  <委托者的公钥>,
  <条件查询字符串>,
  <委托令牌：委托字符串的 sha256 哈希的 64 字节 Schnorr 签名>
]
```

##### 委托令牌

**委托令牌**应该是以下字符串的 sha256 哈希的 64 字节 Schnorr 签名：

```
nostr:delegation:<发布者（受委托者）的公钥>:<条件查询字符串>
```

##### 条件查询字符串

上述查询字符串支持以下字段和操作符：

*字段*：
1. `kind`
   -  *操作符*：
      -  `=${种类编号}` - 受委托者只能签署此种类的事件
2. `created_at`
   -  *操作符*：
      -  `<${时间戳}` - 受委托者只能签署在指定时间戳***之前***创建的事件
      -  `>${时间戳}` - 受委托者只能签署在指定时间戳***之后***创建的事件

为了创建单个条件，您必须使用支持的字段和操作符。可以在单个查询字符串中使用多个条件，包括在同一字段上。条件必须用 `&` 组合。

例如，以下条件字符串是有效的：

- `kind=1&created_at<1675721813`
- `kind=0&kind=1&created_at>1675721813`
- `kind=1&created_at>1674777689&created_at<1675721813`

对于绝大多数用例，建议：
1. 查询字符串应该包含反映当前时间的 `created_at` ***after*** 条件，以防止受委托者代表委托者发布历史笔记。
2. 查询字符串应该包含不为空且不是未来某个极远时间的 `created_at` ***before*** 条件。如果委托在时间范围上不受限制，它们会暴露类似于简单使用根密钥进行身份验证的安全风险。

#### 示例

```
# 委托者：
privkey: ee35e8bb71131c02c1d7e73231daa48e9953d329a4b701f7133c8f46dd21139c
pubkey:  8e0d3d3eb2881ec137a11debe736a9086715a8c8beeeda615780064d68bc25dd

# 受委托者：
privkey: 777e4f60b4aa87937e13acc84f7abcc3c93cc035cb4c1e9f7a9086dd78fffce1
pubkey:  477318cfb5427b9cfc66a9fa376150c1ddbc62115ae27cef72417eb959691396
```

从现在起向受委托者（477318cf）授予笔记发布授权的委托字符串，持续接下来的 30 天，给定当前时间戳是 `1674834236`。
```json
nostr:delegation:477318cfb5427b9cfc66a9fa376150c1ddbc62115ae27cef72417eb959691396:kind=1&created_at>1674834236&created_at<1677426236
```

委托者（8e0d3d3e）然后对上述委托字符串的 SHA256 哈希进行签名，结果就是委托令牌：
```
6f44d7fe4f1c09f3954640fb58bd12bae8bb8ff4120853c4693106c82e920e2b898f1f9ba9bd65449a987c39c0423426ab7b53910c0c6abfb41b30bc16e5f524
```

受委托者（477318cf）现在可以代表委托者（8e0d3d3e）构造事件。受委托者然后用自己的私钥签署事件并发布。
```json
{
  "id": "e93c6095c3db1c31d15ac771f8fc5fb672f6e52cd25505099f62cd055523224f",
  "pubkey": "477318cfb5427b9cfc66a9fa376150c1ddbc62115ae27cef72417eb959691396",
  "created_at": 1677426298,
  "kind": 1,
  "tags": [
    [
      "delegation",
      "8e0d3d3eb2881ec137a11debe736a9086715a8c8beeeda615780064d68bc25dd",
      "kind=1&created_at>1674834236&created_at<1677426236",
      "6f44d7fe4f1c09f3954640fb58bd12bae8bb8ff4120853c4693106c82e920e2b898f1f9ba9bd65449a987c39c0423426ab7b53910c0c6abfb41b30bc16e5f524"
    ]
  ],
  "content": "Hello, world!",
  "sig": "633db60e2e7082c13a47a6b19d663d45b2a2ebdeaf0b4c35ef83be2738030c54fc7fd56d139652937cdca875ee61b51904a1d0d0588a6acd6168d7be2909d693"
}
```

如果条件得到满足（在此示例中为 `kind=1`、`created_at>1674834236` 和 `created_at<1677426236`），并且在验证委托令牌后发现与原始委托字符串中的条件保持不变，则该事件应被视为有效委托。

客户端应该显示委托笔记，就像它是由委托者（8e0d3d3e）直接发布的一样。


#### 中继器和客户端支持

中继器应该通过查询 `pubkey` 和委托标签 `[1]` 值来回答诸如 `["REQ", "", {"authors": ["A"]}]` 的请求。

中继器应该允许委托者（8e0d3d3e）删除受委托者（477318cf）发布的事件。
