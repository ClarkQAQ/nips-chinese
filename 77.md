NIP-77
======

负熵同步
------------------

`草案` `可选`

本文档描述了用于同步事件的协议扩展。它适用于客户端-中继器和中继器-中继器场景。如果同步的双方有共同的事件，那么这个协议将比传输完整的事件集合（甚至只是它们的 ID）使用更少的带宽。

它是围绕 [Negentropy](https://github.com/hoytech/negentropy) 协议的 Nostr 友好包装器，该协议使用一种称为[基于范围的集合调和](https://logperiodic.com/rbsr.html)的技术。

由于 Negentropy 是二进制协议，此包装器对其消息进行十六进制编码。Negentropy 协议 V1 的规范作为本 NIP 下面的附录附上。

## 高级协议描述

我们将参与同步的双方称为客户端和中继器（尽管发起者可能是另一个中继器而不是客户端）。

* (1) 客户端（发起者）选择一个过滤器，检索它在本地匹配此过滤器的事件集合（或使用缓存），并构造初始消息。
* (2) 客户端向中继器发送 `NEG-OPEN` 消息，其中包括过滤器和初始消息。
* (3) 中继器选择它在本地匹配过滤器的事件集合（或使用缓存）。
* (4) 中继器构造响应并在 `NEG-MSG` 消息中将其返回给客户端。
* (5) 客户端解析消息以了解它拥有（中继器需要）的 ID 和它需要（中继器拥有）的 ID。
  * 如果客户端希望继续，则它构造新消息并在 `NEG-MSG` 消息中将其发送到中继器。转到步骤 4。
  * 如果客户端希望停止，则它发送 `NEG-CLOSE` 消息或断开 websocket 连接。

上述协议只导致客户端了解它拥有/需要的 ID，并不实际传输事件。给定这些 ID，客户端可以用 `EVENT` 上传它拥有的事件，和/或用 `REQ` 下载它需要的事件。这可以在同一个 websocket 连接上与后续的 `NEG-MSG` 消息并行执行。如果客户端只对确定唯一事件数量（即反应计数）感兴趣，它可能选择完全不下载/上传。

## Nostr 消息

### 初始消息（客户端到中继器）：

```jsonc
[
    "NEG-OPEN",
    <订阅 ID 字符串>,
    <过滤器>,
    <初始消息，十六进制编码>
]
```

* 订阅 ID 被双方用于识别消息引用的查询。它只需要足够长以将其与此 websocket 连接上任何其他并发订阅区分开（每个 `NEG-OPEN` 递增一次的整数就可以）。订阅 ID 在与 `REQ` 订阅 ID 分离的命名空间中。如果为当前打开的订阅 ID 发出 `NEG-OPEN`，现有订阅首先关闭。
* 过滤器如 [NIP-01](01_ZH.md) 中描述的。
* `initialMessage` 是初始 Negentropy 二进制消息，十六进制编码。见附录。

### 错误消息（中继器到客户端）：

如果请求不能被中继器服务，向客户端返回错误：

```jsonc
[
    "NEG-ERR",
    <订阅 ID 字符串>,
    <原因代码字符串>
]
```

错误原因与 NIP-01 中的格式相同。它们应该以机器可读的单词前缀开始，后跟 `:` 然后是带有更多信息的人类可读消息。

当前建议的错误原因是

* `blocked`
  * 中继器可以选择拒绝需要它们处理太多记录或太旧记录的查询
  * 可以处理的最大记录数可以选择性地作为响应中的第 4 个元素返回
  * 示例：`blocked: this query is too big`
* `closed`
  * 因为 `NEG-OPEN` 查询可能是有状态的，中继器可能选择超时不活跃的查询以恢复内存资源
  * 示例：`closed: you took too long to respond!`

发出 `NEG-ERR` 后，订阅被视为已关闭。

### 后续消息（双向）：

中继器和客户端交替发送彼此 `NEG-MSG`：

```jsonc
[
    "NEG-MSG",
    <订阅 ID 字符串>,
    <消息，十六进制编码>
]
```

* `message` 是 Negentropy 二进制消息，十六进制编码。两个消息方向使用相同格式。见附录。

### 关闭消息（客户端到中继器）：

完成后，客户端应该用 `NEG-CLOSE` 告诉中继器它可以释放其资源：

```jsonc
[
    "NEG-CLOSE",
    <订阅 ID 字符串>
]
```


## 附录：Negentropy 协议 V1

### 准备

有两个协议参与者：客户端和服务器。客户端创建初始消息并将其传输到服务器，服务器回复自己的消息作为响应。客户端继续查询服务器直到满足，然后终止协议。任一方向的消息具有相同格式。

每个参与者都有记录集合。记录由 64 位数字时间戳和 256 位 ID 组成。每个参与者开始时按时间戳升序排序其项目。如果两个时间戳相等，则项目按 ID 字典序排序，按第一个不同字节升序。项目不能使用最大 uint64 值（`2**64 - 1`）作为时间戳，因为这被保留为特殊的"无穷大"值。

协议的目标是让客户端了解它拥有而服务器没有的 ID 集合，以及服务器拥有而它没有的项目集合。

### `Varint`

变长整数（可变大小无符号整数）表示为 base-128 数字，最高有效数字在前，尽可能少的数字。除最后一个字节外，每个字节都设置第八位（高位）。

    Varint := <Digit+128>* <Digit>

### `Id`

ID 表示为长度 `32` 的字节字符串：

    Id := Byte{32}

### `Message`

调和消息是协议版本字节后跟有序范围列表：

    Message := <protocolVersion (Byte)> <Range>*

当前协议版本是 1，由字节 `0x61` 表示。协议版本 2 将是 `0x62`，依此类推。如果服务器收到它无法处理的协议版本的消息，它应该回复包含它支持的最高协议版本的单个字节，允许客户端降级并重试其消息。

每个 Range 对应于时间戳/ID 空间的连续部分。第一个 Range 从时间戳 0 和 0 字节的 ID 开始。Range 始终相邻（无间隙）。如果最后一个 Range 不以特殊无穷大值结束，则追加隐式 `Skip` 到无穷大 Range。这意味着 Range 列表始终覆盖完整的时间戳/ID 空间。

### `Range`

Range 由上界、模式和载荷组成：

    Range := <upperBound (Bound)> <mode (Varint)> <payload (Skip | Fingerprint | IdList)>

载荷的内容由模式确定：

* 如果 `mode = 0`，则载荷是 `Skip`，意味着发送者不希望进一步处理此 Range。此载荷为空：

      Skip :=

* 如果 `mode = 1`，则载荷是 `Fingerprint`，这是发送者在 Range 内拥有的所有 ID 的[摘要](#fingerprint-algorithm)：

      Fingerprint := Byte{16}

* 如果 `mode = 2`，载荷是 `IdList`，发送者在 Range 内拥有的所有 ID 的可变长度列表：

      IdList := <length (Varint)> <ids (Id)>*


### `Bound`

每个 Range 由*包含*下界和*排除*上界指定。如上所述，每个 Range 只包含上界：Range 的下界是前一个 Range 的上界，或第一个 Range 的 0 时间戳/0 ID。

Bound 由编码时间戳和 ID 的可变长度消歧前缀组成（以防多个项目具有相同时间戳）：

    Bound := <encodedTimestamp (Varint)> <length (Varint)> <idPrefix (Byte)>*

* 时间戳特殊编码。无穷大时间戳编码为 `0`。所有其他值编码为 `1 + offset`，其中 offset 是此时间戳与先前编码时间戳之间的差异。初始 offset 从 `0` 开始，在每条消息开始时重置。

  Offset 始终非负，因为上界的时间戳大于或等于下界的时间戳，消息中的范围始终按升序编码，范围从不重叠。

* `idPrefix` 的大小在 `length` 中编码，可以在 `0` 和 `32` 字节之间，包含。这允许实现使用最短可能的前缀来分离此 Range 的第一个记录和前一个 Range 的最后一个记录。如果这些记录的时间戳不同，则长度应为 0，否则应为其公共 ID 前缀的字节长度加 1。

  如果 `idPrefix` 长度小于 `32`，则省略的尾随字节隐式为 0 字节。


### 指纹算法

Range 的指纹用以下算法计算：

* 计算元素 ID 的加法模 2<sup>256</sup>（解释为 32 字节小端无符号整数）
* 与 Range 中的元素数量连接，编码为 [Varint](#varint)
* 用 SHA-256 哈希
* 取前 16 字节
