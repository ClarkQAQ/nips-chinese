NIP-34
======

`git` 相关功能
-----------

`草案` `可选`

本 NIP 定义了使用和邻近 [`git`](https://git-scm.com/) 的代码协作可以使用 Nostr 完成的所有方式。

## 仓库公告

Git 仓库托管在支持 Git 的服务器中，但它们的存在可以使用 Nostr 事件公布，以及它们接收补丁、错误报告和一般评论的意愿。

```jsonc
{
  "kind": 30617,
  "content": "",
  "tags": [
    ["d", "<仓库ID>"], // 通常是短横线分隔的短名称
    ["name", "<人类可读的项目名称>"],
    ["description", "简短的人类可读项目描述>"],
    ["web", "<浏览URL>", ...], // 网页 URL，如果使用的 git 服务器提供这样的功能
    ["clone", "<git克隆URL>", ...], // 要提供给 `git clone` 的 URL，这样任何人都可以克隆它
    ["relays", "<中继器URL>", ...], // 此仓库将监控补丁和问题的中继器
    ["r", "<最早唯一提交ID>", "euc"],
    ["maintainers", "<其他认可的维护者>", ...],
    ["t", "<任意字符串>"], // 标记仓库的标签
  ]
}
```

标签 `web`、`clone`、`relays`、`maintainers` 可以有多个值。

带有 `"euc"` 标记注释的 `r` 标签应该是此仓库最早唯一提交的提交 ID，用于在分叉中识别它并将其与可能托管在其他地方的其他仓库分组，这些仓库可能代表本质上相同的项目。在大多数情况下，它将是仓库的根提交。在两个项目之间永久分叉的情况下，应该使用分叉后的第一个提交。

除了 `d`，所有标签都是可选的。

## 仓库状态公告

仓库中分支和标签状态的可选真实来源。

```jsonc
{
  "kind": 30618,
  "content": "",
  "tags": [
    ["d", "<仓库ID>"], // 匹配相应仓库公告中的标识符
    ["refs/<heads|tags>/<分支或标签名称>","<提交ID>"]
    ["HEAD", "ref: refs/heads/<分支名称>"]
  ]
}
```

`refs` 标签可能出现多次，或者不出现。

如果没有 `refs` 标签，作者不再使用此事件跟踪仓库状态。这种方法使作者能够在以后重新开始跟踪状态，与 [NIP-09](09_ZH.md) 删除请求不同。

`refs` 标签可以可选地扩展以使客户端能够识别引用领先多少个提交：

```jsonc
{
  "tags": [
    ["refs/<heads|tags>/<分支或标签名称>", "<提交ID>", "<简写父提交ID>", "<简写祖父提交>", ...],
  ]
}
```

## 补丁

补丁可以由任何人发送到任何仓库。发送到特定仓库的补丁应该发送到该仓库公告事件的 `"relays"` 标签中指定的中继器。补丁事件应该包含指向该仓库公告地址的 `a` 标签。

补丁集中的补丁应该包含指向上一个补丁的 [NIP-10](10_ZH.md) `e` `reply` 标签。

补丁修订中的第一个补丁修订应该包含对原始根补丁的 [NIP-10](10_ZH.md) `e` `reply`。

```jsonc
{
  "kind": 1617,
  "content": "<补丁>", // <git format-patch> 的内容
  "tags": [
    ["a", "30617:<基础仓库所有者公钥>:<基础仓库ID>"],
    ["r", "<仓库的最早唯一提交ID>"] // 这样客户端可以订阅发送到本地 git 仓库的所有补丁
    ["p", "<仓库所有者>"],
    ["p", "<其他用户>"], // 可选地将补丁发送给另一个用户以引起他们的注意

    ["t", "root"], // 对于系列中的附加补丁省略
    // 对于修订中的第一个补丁
    ["t", "root-revision"],

    // 当希望合并的补丁具有稳定的提交 ID 时的可选标签
    // 这些字段对于确保应用补丁产生的提交具有与提议者机器中相同的 ID 是必要的 -- 如果维护者不关心这些事情，可以省略所有这些标签
    ["commit", "<当前提交ID>"],
    ["r", "<当前提交ID>"] // 这样客户端可以找到特定提交的现有补丁
    ["parent-commit", "<父提交ID>"],
    ["commit-pgp-sig", "-----BEGIN PGP SIGNATURE-----..."], // 未签名提交的空字符串
    ["committer", "<名称>", "<电子邮件>", "<时间戳>", "<时区偏移分钟>"],
  ]
}
```

系列中的第一个补丁可能是 `git format-patch` 产生的格式的封面信。

## 问题

问题是与仓库相关的人类可读对话线程的 Markdown 文本：错误报告、功能请求、任何类型的问题或评论。与补丁一样，这些应该发送到该仓库公告事件的 `"relays"` 标签中指定的中继器。

问题可能有 `subject` 标签，客户端可以利用它来显示标题。此外，可以包含一个或多个 `t` 标签来为问题提供标签。

```json
{
  "kind": 1621,
  "content": "<markdown 文本>",
  "tags": [
    ["a", "30617:<基础仓库所有者公钥>:<基础仓库ID>"],
    ["p", "<仓库所有者>"]
    ["subject", "<问题主题>"]
    ["t", "<问题标签>"]
    ["t", "<另一个问题标签>"]
  ]
}
```

## 回复

对 `kind:1621`（_问题_）或 `kind:1617`（_补丁_）事件的回复应该遵循 [NIP-22 评论](22_ZH.md)。

## 状态

根补丁和问题有一个默认为"打开"的状态，可以通过发出状态事件来设置。

```jsonc
{
  "kind": 1630, // 打开
  "kind": 1631, // 补丁已应用/合并；问题已解决
  "kind": 1632, // 关闭
  "kind": 1633, // 草稿
  "content": "<markdown 文本>",
  "tags": [
    ["e", "<问题或原始根补丁ID十六进制>", "", "root"],
    ["e", "<接受的修订根ID十六进制>", "", "reply"], // 当修订应用时
    ["p", "<仓库所有者>"],
    ["p", "<根事件作者>"],
    ["p", "<修订作者>"],

    // 可选，用于改进订阅过滤器效率
    ["a", "30617:<基础仓库所有者公钥>:<基础仓库ID>", "<中继器URL>"],
    ["r", "<仓库的最早唯一提交ID>"]

    // `1631` 状态的可选项
    ["q", "<应用或合并的补丁事件ID>", "<中继器URL>", "<公钥>"], // 每个
    // 当合并时
    ["merge-commit", "<合并提交ID>"]
    ["r", "<合并提交ID>"]
    // 当应用时
    ["applied-as-commits", "<主分支中的提交ID>", ...]
    ["r", "<应用的提交ID>"] // 每个
  ]
}
```

来自问题/补丁作者或维护者的最近状态事件（按 `created_at` 日期）被认为是有效的。

补丁修订的状态要么是根补丁的状态，要么如果根补丁的状态是 `1631`（_已应用/合并_）而补丁修订没有在 `1631`（_已应用/合并_）事件中标记，则为 `1632`（_关闭_）。


## 可能稍后添加的内容

- "分支合并"种类（指定从哪里获取要合并的分支的 URL）
- 内联文件评论种类（我们可能需要一个用于补丁，一个用于合并文件的不同种类）
