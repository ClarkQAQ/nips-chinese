NIP-89
======

推荐应用程序处理程序
--------------------------------

`草案` `可选`

此 NIP 描述了 `kind:31989` 和 `kind:31990`：一种发现可以处理未知事件类型的应用程序的方法。

## 理由

Nostr 的可发现性和透明事件交互是其最有趣/新颖的机制之一。
此 NIP 为客户端提供了一种简单的方法来发现处理特定类型事件的应用程序，以确保顺畅的跨客户端和跨类型交互。

### 涉及的各方

此工作流程中有三个参与者：

* 处理特定事件类型的应用程序（请注意，应用程序不一定需要是不同的实体，它可以只是与用户 A 相同的公钥）
    * 发布 `kind:31990`，详细说明应用程序应该如何重定向到它
* 用户 A，推荐处理特定事件类型的应用程序
    * 发布 `kind:31989`
* 用户 B，寻求处理特定事件类型的应用程序推荐
    * 查询 `kind:31989`，根据结果查询 `kind:31990`

## 事件

### 推荐事件
```jsonc
{
  "kind": 31989,
  "pubkey": <推荐者用户公钥>,
  "tags": [
    ["d", <支持的事件类型>],
    ["a", "31990:app1-pubkey:<d标识符>", "wss://relay1", "ios"],
    ["a", "31990:app2-pubkey:<d标识符>", "wss://relay2", "web"]
  ],
  // 其他字段...
}
```

`kind:31989` 中的 `d` 标签是此事件推荐的支持的事件类型。

多个 `a` 标签可以出现在同一个 `kind:31989` 上。

标签的第二个值应该是中继器提示。
标签的第三个值应该是此推荐可能适用的平台。

### 处理程序信息
```jsonc
{
  "kind": 31990,
  "pubkey": "<应用程序公钥>",
  "content": "<可选的类似kind:0样式的元数据>",
  "tags": [
    ["d", <随机ID>],
    ["k", <支持的事件类型>],
    ["web", "https://..../a/<bech32>", "nevent"],
    ["web", "https://..../p/<bech32>", "nprofile"],
    ["web", "https://..../e/<bech32>"],
    ["ios", ".../<bech32>"]
  ],
  // 其他字段...
}
```

* `content` 是一个可选的类似 `metadata` 的字符串化 JSON 对象，如 NIP-01 中所述。当创建 `kind:31990` 的公钥不是应用程序时，此内容很有用。如果 `content` 为空，应该使用公钥的 `kind:0` 来显示应用程序信息（例如名称、图片、网站、LUD16 等）
* `k` 标签的值是此 `kind:31990` 支持的事件类型。
使用 `k` 标签（而不是将类型作为 `d` 标签）提供：
    * 如果应用程序支持多个事件类型且其处理程序 URL 相同，则可以在同一事件中存在多个 `k` 标签。
    * 同一公钥可以有多个处理相同事件类型的不同应用程序的事件。
* URL 中的 `bech32` 必须由客户端替换为应由应用程序加载的 NIP-19 编码实体。

应用程序可能注册多个标签，遵循 NIP-19 命名法作为数组的第二个值。

数组中没有第二个值的标签应该被认为是任何未由不同标签处理的 NIP-19 实体的通用处理程序。

## 客户端标签
发布事件时，客户端可以包含 `client` 标签。标识发布笔记的客户端。此标签是标识处理程序事件的 `name`、`address` 和用于查找处理程序事件的中继器 `hint` 的元组。这对用户有隐私影响，因此客户端应该允许用户选择不使用此标签。

```jsonc
{
  "kind": 1,
  "tags": [
    ["client", "My Client", "31990:app1-pubkey:<d标识符>", "wss://relay1"]
  ]
  // 其他字段...
}
```

## 用户流程
使用非 `kind:1` 中心的 nostr 应用程序的用户 A 可以选择宣布/推荐某个类型处理程序应用程序。

当用户 B 看到未知事件类型时，例如在以社交媒体为中心的 nostr 客户端中，客户端将允许用户 B 与未知类型事件交互（例如点击它）。

客户端可能查询用户和用户关注的处理程序。

## 示例

### 用户 A 推荐 `kind:31337` 处理程序
用户 A 可能是 Zapstr 的用户，一个 `kind:31337` 中心的客户端（tracks）。使用 Zapstr，用户 A 发布推荐 Zapstr 作为 `kind:31337` 处理程序的事件。

```jsonc
{
  "kind": 31989,
  "tags": [
    ["d", "31337"],
    ["a", "31990:1743058db7078661b94aaf4286429d97ee5257d14a86d6bfa54cb0482b876fb0:abcd", <中继URL>, "web"]
  ],
  // 其他字段...
}
```

### 用户 B 与 `kind:31337` 处理程序交互
用户 B 可能在其时间线中看到引用 `kind:31337` 事件的事件（例如标记 `kind:31337` 的 `kind:1`）。

用户 B 的客户端不知道如何处理 `kind:31337`，可能使用其 `alt` 标签（如 NIP-31 中所述）显示事件。当用户点击事件时，应用程序查询此 `kind` 的处理程序：

```
["REQ", <id>, { "kinds": [31989], "#d": ["31337"], "authors": [<用户>, <用户联系人列表>] }]
```

关注用户 A 的用户 B 看到了 `kind:31989` 事件并获取应用程序和处理程序信息的 `a` 标记事件。

用户 B 的客户端看到应用程序的 `kind:31990`，其中包含将用户重定向到相关 URL 的信息，并在 URL 中替换所需实体。

### 绕过 `kind:31989` 的替代查询
或者，用户可能选择直接查询事件类型的 `kind:31990`。客户端在执行此操作时应该小心，并使用垃圾邮件防护机制或查询高质量的受限中继器，以避免将用户引导到恶意处理程序。

```
["REQ", <id>, { "kinds": [31990], "#k": [<所需事件类型>], "authors": [...] }]
```
