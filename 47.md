NIP-47
======

Nostr 钱包连接 (NWC)
--------------------

`草案` `可选`

## 原理

本 NIP 描述了客户端通过标准化协议访问远程闪电钱包的方法。托管方可以实现这个，或者用户可以运行桥接其钱包/节点和 Nostr 钱包连接协议的桥接器。

## 术语

* **客户端**：任何平台上想要与闪电钱包交互的 Nostr 应用程序。
* **用户**：使用 **客户端** 的人，想要将他们的钱包连接到他们的 **客户端**。
* **钱包服务**：通常运行在始终在线计算机上的 Nostr 应用程序（例如在云端或树莓派上）。此应用程序可以访问它服务的钱包的 API。

## 操作理论

从根本上说，NWC 是通过 nostr 中继器上的 E2E 加密直接消息在 **客户端** 和 **钱包服务** 之间进行的通信。中继器知道笔记的种类和标签，但不知道加密载荷的内容。不使用 **用户** 的身份密钥以避免将支付活动与用户关联。理想情况下，每个单独的连接使用唯一密钥。

 1. 希望使用此 NIP 允许 **客户端** 与其钱包交互的 **用户** 必须首先从其符合 NIP-47 的钱包应用程序获取特殊的"连接" URI。钱包应用程序可以使用二维码屏幕、可粘贴字符串或其他方式提供此 URI。
 
 2. 然后 **用户** 应该通过粘贴或扫描二维码等方式将此 URI 复制到他们的 **客户端** 中。**客户端** 应该保存此 URI 并在 **用户**（或客户端代表用户）想要与钱包交互时稍后使用它。然后 **客户端** 应该从 URI 中指定的中继器请求 `info` (13194) 事件。**钱包服务** 将之前向这些中继器发送该事件，中继器将其作为可替换事件保存。
 
 3. 当 **用户** 发起支付时，他们的 nostr **客户端** 创建 `pay_invoice` 请求，使用 URI 中的令牌加密它，并将其（种类 23194）发送到连接 URI 中指定的中继器。**钱包服务** 将监听这些中继器，解密请求，然后联系 **用户** 的钱包应用程序发送支付。**钱包服务** 将知道如何与钱包应用程序通信，因为连接 URI 指定了可以访问钱包应用程序 API 的中继器。
 
 4. 支付完成后，**钱包服务** 将通过 URI 中的中继器向 **用户** 发送加密的 `response`（种类 23195）。
 
 5. **钱包服务** 可能向 **客户端** 发送钱包事件（如收到支付）的加密通知（种类 23197 或 23196）。

## 事件

有四种事件种类：

- `NIP-47 info event`：13194
- `NIP-47 request`：23194
- `NIP-47 response`：23195
- `NIP-47 notification event`：23197（23196 用于与 NIP-04 的向后兼容）

### Info 事件

info 事件应该是由 **钱包服务** 在中继器上发布的可替换事件，以指示它支持哪些功能。

内容应该是支持的功能的明文字符串，用空格分隔，例如 `pay_invoice get_balance notifications`。

如果 **钱包服务** 支持通知，info 事件应该包含一个 `notifications` 标签，其中包含支持的通知类型，用空格分隔，例如 `payment_received payment_sent`。

它还应该包含如[加密](#encryption)部分所述的支持的加密模式。例如：

```jsonc
{
    "kind": 13194,
    "tags": [
        ["encryption", "nip44_v2 nip04"], // 如加密部分所述的支持的加密方案列表。
        ["notifications", "payment_received payment_sent"]
        // ...
    ],
    "content": "pay_invoice get_balance make_invoice lookup_invoice list_transactions get_info notifications",
    // ...
}
```

### 请求和响应事件

请求和响应事件都应该包含一个 `p` 标签，如果这是请求则包含 **钱包服务** 的公钥，如果这是响应则包含 **客户端** 的公钥。响应事件应该包含一个带有它响应的请求事件 ID 的 `e` 标签。
可选地，请求可以有一个 `expiration` 标签，其中包含以秒为单位的 unix 时间戳。如果在此时间戳之后收到请求，应该忽略它。

请求和响应的内容使用 [NIP44](44.md) 加密，是具有半固定结构的类似 JSON-RPC 的对象。

**向后兼容的重要说明：** 协议的初始版本使用 [NIP04](04.md)。如果 **钱包服务** 或客户端应用程序在 `info` 或请求事件中不包含 `encryption` 标签，应假设连接使用 NIP04 进行加密。有关更多信息，请参阅[加密](#encryption)部分。

示例请求：

```js
{
    "kind" 23194,
    "tags": [
        ["encryption", "nip44_v2"],
        ["p", "03..." ] // 钱包服务的公钥。
        // ...
    ],
    "content": nip44_encrypt({ // 加密类型对应于 `encryption` 标签。
        "method": "pay_invoice", // 方法，字符串
        "params": { // 参数，对象
            "invoice": "lnbc50n1..." // 命令相关数据
        }
    }),
}
```

示例响应：

```js
{
    "kind" 23195,
    "tags": [
        ["p", "03..." ] // 请求客户端应用程序的公钥
        ["e", "1234"] // 这是响应的请求事件的 ID
        // ...
    ],
    "content": nip44_encrypt({ // 使用客户端请求的方案加密。
        "result_type": "pay_invoice", //指示结果字段的结构
        "error": { //对象，错误情况下非空
            "code": "UNAUTHORIZED", //字符串错误代码，见下文
            "message": "人类可读的错误消息"
        },
        "result": { // 结果，对象。错误情况下为 null。
            "preimage": "0123456789abcdef..." // 命令相关数据
        }
    })
    // ...
}
```

`result_type` 字段必须包含此事件响应的方法名称。
如果命令不成功，`error` 字段必须包含带有人类可读错误消息的 `message` 字段和带有错误代码的 `code` 字段。
如果命令成功，`error` 字段必须为 null。

### 通知事件

通知事件是种类 23197 事件，应该包含一个 `p` 标签，即 **客户端** 的公钥。

通知的内容使用 [NIP44](44.md)（或传统客户端应用程序的 NIP-04）加密，是具有半固定结构的类似 JSON-RPC 的对象：

```jsonc
{
    "notification_type": "payment_received", //指示通知字段的结构
    "notification": {
        "payment_hash": "0123456789abcdef..." // 通知相关数据
    }
}
```

_向后兼容性说明：_ 如果 **钱包服务** 支持 nip44 和 nip04 以支持传统客户端应用程序，它应该为每个通知发布两个通知事件 - 用 NIP-04 加密的种类 23196 和用 NIP-44 加密的种类 23197。**客户端** 根据其支持的加密和 **钱包服务** 在 `info` 事件中声明的支持的加密方案决定监听哪个事件。

### 错误代码
- `RATE_LIMITED`：客户端发送命令太快。它应该在几秒钟内重试。
- `NOT_IMPLEMENTED`：命令未知或故意未实现。
- `INSUFFICIENT_BALANCE`：钱包没有足够的资金来支付手续费储备或支付金额。
- `QUOTA_EXCEEDED`：钱包已超过其支出配额。
- `RESTRICTED`：此公钥不允许执行此操作。
- `UNAUTHORIZED`：此公钥没有连接钱包。
- `INTERNAL`：内部错误。
- `UNSUPPORTED_ENCRYPTION`：钱包服务不支持请求的加密类型。
- `OTHER`：其他错误。

## Nostr 钱包连接 URI

**客户端** 和 **钱包服务** 之间的通信需要两个密钥来加密和解密消息。连接 URI 包括 **客户端** 的秘密密钥和仅 **钱包服务** 的公钥。

**客户端** 通过扫描二维码、处理深度链接或粘贴 URI 来发现 **钱包服务**。

**钱包服务** 使用协议 `nostr+walletconnect://` 和基本路径其 32 字节十六进制编码的 `pubkey` 生成此连接 URI，该 pubkey 应该对每个客户端连接都是唯一的。

连接 URI 包含以下查询字符串参数：

- `relay` 必需。**钱包服务** 连接并将监听事件的中继器的 URL。可能有多个。
- `secret` 必需。32 字节随机生成的十六进制编码字符串。**客户端** 必须使用此来签署事件并在与 **钱包服务** 通信时加密载荷。**钱包服务** 必须使用此秘密的相应公钥与 **客户端** 通信。
    - 授权不需要来回传递密钥。
    - 用户可以为不同应用程序拥有不同密钥。密钥可以随意撤销和创建，并具有任意约束（例如预算）。
    - 密钥更难泄露，因为它不向用户显示并备份。
    - 它改善了隐私，因为用户的主密钥不会与其支付关联。
- `lud16` 推荐。客户端可以使用的闪电地址，如果用户没有配置，则自动设置用户档案上的 `lud16` 字段。

然后 **客户端** 应该存储此连接并在用户想要执行支付发票等操作时使用它。由于此 NIP 使用临时事件，建议选择不会在不活跃时关闭连接以免丢失事件的中继器，理想情况下保留事件直到它们被消费或变得陈旧。

- 当 **客户端** 发送或接收消息时，它将使用连接 URI 中的 `secret` 和 **钱包服务** 的 `pubkey` 来加密或解密。
- 当 **钱包服务** 发送或接收消息时，它将使用自己的秘密和 **客户端** `secret` 的相应公钥来加密或解密。**钱包服务** 不应存储它为客户端生成的秘密，并且不得依赖于知道 **客户端** 秘密进行一般操作。

### 示例连接字符串
```sh
nostr+walletconnect://b889ff5b1513b641e2a139f661a661364979c5beee91842f8f0ef42ab558e9d4?relay=wss%3A%2F%2Frelay.damus.io&secret=71a8c14c1407c113601079c4302dab36460f0ccd0ad506f1f2dc73b5100e4f3c
```

## 命令

### `pay_invoice`

描述：请求支付发票。

请求：
```jsonc
{
    "method": "pay_invoice",
    "params": {
        "invoice": "lnbc50n1...", // bolt11 发票
        "amount": 123, // 发票金额（毫聪），可选
        "metadata": {} // 可用于添加打赏/增强图详细信息的付款人姓名/评论等的通用元数据，可选
    }
}
```

响应：
```jsonc
{
    "result_type": "pay_invoice",
    "result": {
        "preimage": "0123456789abcdef...", // 支付的原像
        "fees_paid": 123, // 毫聪值，可选
    }
}
```

错误：
- `PAYMENT_FAILED`：支付失败。这可能是由于超时、路由耗尽、容量不足或类似原因。

### `multi_pay_invoice`

描述：请求支付多个发票。

请求：
```jsonc
{
    "method": "multi_pay_invoice",
    "params": {
        "invoices": [
          {"id":"4da52c32a1", "invoice": "lnbc1...", "amount": 123}, // bolt11 发票和毫聪金额，金额可选
          {"id":"3da52c32a1", "invoice": "lnbc50n1...", "metadata": {} }, // 可用于添加打赏/增强图详细信息的付款人姓名/评论等的通用元数据，可选
        ],
    }
}
```

响应：

对于请求中的每个发票，发送单独的响应事件。为了区分响应，每个响应事件包含一个带有它响应的发票 ID 的 `d` 标签；如果没有给出 ID，则应使用发票的支付哈希。

```jsonc
{
    "result_type": "multi_pay_invoice",
    "result": {
        "preimage": "0123456789abcdef...", // 支付的原像
        "fees_paid": 123, // 毫聪值，可选
    }
}
```

错误：
- `PAYMENT_FAILED`：支付失败。这可能是由于超时、路由耗尽、容量不足或类似原因。

### `pay_keysend`

请求：
```jsonc
{
    "method": "pay_keysend",
    "params": {
        "amount": 123, // 发票金额（毫聪），必需
        "pubkey": "03...", // 收款人公钥，必需
        "preimage": "0123456789abcdef...", // 支付的原像，可选
        "tlv_records": [ // tlv 记录，可选
            {
                "type": 5482373484, // tlv 类型
                "value": "0123456789abcdef" // 十六进制编码的 tlv 值
            }
        ]
    }
}
```

响应：
```jsonc
{
    "result_type": "pay_keysend",
    "result": {
        "preimage": "0123456789abcdef...", // 支付的原像
        "fees_paid": 123, // 毫聪值，可选
    }
}
```

错误：
- `PAYMENT_FAILED`：支付失败。这可能是由于超时、路由耗尽、容量不足或类似原因。

### `multi_pay_keysend`

描述：请求多个 keysend 支付。

有一个 keysend 数组，这些遵循与 `pay_keysend` 相同的语义，只是批量完成

请求：
```jsonc
{
    "method": "multi_pay_keysend",
    "params": {
        "keysends": [
          {"id": "4c5b24a351", "pubkey": "03...", "amount": 123},
          {"id": "3da52c32a1", "pubkey": "02...", "amount": 567, "preimage": "abc123..", "tlv_records": [{"type": 696969, "value": "77616c5f6872444873305242454d353736"}]},
        ],
    }
}
```

响应：

对于请求中的每个 keysend，发送单独的响应事件。为了区分响应，每个响应事件包含一个带有它响应的 keysend ID 的 `d` 标签；如果没有给出 ID，则应使用公钥。

```jsonc
{
    "result_type": "multi_pay_keysend",
    "result": {
        "preimage": "0123456789abcdef...", // 支付的原像
        "fees_paid": 123, // 毫聪值，可选
    }
}
```

错误：
- `PAYMENT_FAILED`：支付失败。这可能是由于超时、路由耗尽、容量不足或类似原因。

### `make_invoice`

请求：
```jsonc
{
    "method": "make_invoice",
    "params": {
        "amount": 123, // 毫聪值
        "description": "string", // 发票的描述，可选
        "description_hash": "string", // 发票的描述哈希，可选
        "expiry": 213, // 从发票创建时间开始的过期时间（秒），可选
        "metadata": {} // 可用于添加打赏/增强图详细信息的付款人姓名/评论等的通用元数据，可选
    }
}
```

响应：
```jsonc
{
    "result_type": "make_invoice",
    "result": {
        "type": "incoming", // 发票为"incoming"，支付为"outgoing"
        "state": "pending", // 可选
        "invoice": "string", // 编码的发票，可选
        "description": "string", // 发票的描述，可选
        "description_hash": "string", // 发票的描述哈希，可选
        "preimage": "string", // 支付的原像，如果未支付则可选
        "payment_hash": "string", // 支付的支付哈希
        "amount": 123, // 毫聪值
        "fees_paid": 123, // 毫聪值
        "created_at": unixtimestamp, // 发票/支付创建时间
        "expires_at": unixtimestamp, // 发票过期时间，如果不适用则可选
        "metadata": {} // 可用于添加打赏/增强图详细信息的付款人姓名/评论等的通用元数据。
    }
}
```

### `lookup_invoice`

请求：
```jsonc
{
    "method": "lookup_invoice",
    "params": {
        "payment_hash": "31afdf1..", // 发票的支付哈希，payment_hash 或 invoice 之一是必需的
        "invoice": "lnbc50n1..." // 要查找的发票
    }
}
```

响应：
```jsonc
{
    "result_type": "lookup_invoice",
    "result": {
        "type": "incoming", // 发票为"incoming"，支付为"outgoing"
        "state": "pending", // 可以是"pending"、"settled"、"expired"（对于发票）或"failed"（对于支付），可选
        "invoice": "string", // 编码的发票，可选
        "description": "string", // 发票的描述，可选
        "description_hash": "string", // 发票的描述哈希，可选
        "preimage": "string", // 支付的原像，如果未支付则可选
        "payment_hash": "string", // 支付的支付哈希
        "amount": 123, // 毫聪值
        "fees_paid": 123, // 毫聪值
        "created_at": unixtimestamp, // 发票/支付创建时间
        "expires_at": unixtimestamp, // 发票过期时间，如果不适用则可选
        "settled_at": unixtimestamp, // 发票/支付结算时间，如果未支付则可选
        "metadata": {} // 可用于添加打赏/增强图详细信息的付款人姓名/评论等的通用元数据。
    }
}
```

错误：
- `NOT_FOUND`：无法通过给定参数找到发票。

### `list_transactions`

列出发票和支付。如果未指定 `type`，则返回发票和支付。
`from` 和 `until` 参数是自纪元以来的秒时间戳。如果未指定 `from`，则默认为 0。
如果未指定 `until`，则默认为当前时间。交易按创建时间降序返回。

请求：
```jsonc
{
    "method": "list_transactions",
    "params": {
        "from": 1693876973, // 自纪元以来的开始时间戳（秒）（包含），可选
        "until": 1703225078, // 自纪元以来的结束时间戳（秒）（包含），可选
        "limit": 10, // 返回的最大发票数，可选
        "offset": 0, // 返回的第一个发票的偏移量，可选
        "unpaid": true, // 包括未支付的发票，可选，默认 false
        "type": "incoming", // 发票为"incoming"，支付为"outgoing"，两者都未定义
    }
}
```

响应：
```jsonc
{
    "result_type": "list_transactions",
    "result": {
        "transactions": [
            {
               "type": "incoming", // 发票为"incoming"，支付为"outgoing"
               "state": "pending", // 可以是"pending"、"settled"、"expired"（对于发票）或"failed"（对于支付），可选
               "invoice": "string", // 编码的发票，可选
               "description": "string", // 发票的描述，可选
               "description_hash": "string", // 发票的描述哈希，可选
               "preimage": "string", // 支付的原像，如果未支付则可选
               "payment_hash": "string", // 支付的支付哈希
               "amount": 123, // 毫聪值
               "fees_paid": 123, // 毫聪值
               "created_at": unixtimestamp, // 发票/支付创建时间
               "expires_at": unixtimestamp, // 发票过期时间，如果不适用则可选
               "settled_at": unixtimestamp, // 发票/支付结算时间，如果未支付则可选
               "metadata": {} // 可用于添加打赏/增强图详细信息的付款人姓名/评论等的通用元数据。
           }
        ],
    },
}
```

### `get_balance`

请求：
```jsonc
{
    "method": "get_balance",
    "params": {}
}
```

响应：
```jsonc
{
    "result_type": "get_balance",
    "result": {
        "balance": 10000, // 用户的余额（毫聪）
    }
}
```

### `get_info`

请求：
```jsonc
{
    "method": "get_info",
    "params": {}
}
```

响应：
```jsonc
{
    "result_type": "get_info",
    "result": {
            "alias": "string",
            "color": "hex string",
            "pubkey": "hex string",
            "network": "string", // mainnet, testnet, signet, 或 regtest
            "block_height": 1,
            "block_hash": "hex string",
            "methods": ["pay_invoice", "get_balance", "make_invoice", "lookup_invoice", "list_transactions", "get_info"], // 此连接支持的方法列表
            "notifications": ["payment_received", "payment_sent"], // 此连接支持的通知列表，可选。
    }
}
```

## 通知

### `payment_received`

描述：钱包成功收到支付。

通知：
```jsonc
{
    "notification_type": "payment_received",
    "notification": {
        "type": "incoming",
        "state": "settled", // 可选
        "invoice": "string", // 编码的发票
        "description": "string", // 发票的描述，可选
        "description_hash": "string", // 发票的描述哈希，可选
        "preimage": "string", // 支付的原像
        "payment_hash": "string", // 支付的支付哈希
        "amount": 123, // 毫聪值
        "fees_paid": 123, // 毫聪值
        "created_at": unixtimestamp, // 发票/支付创建时间
        "expires_at": unixtimestamp, // 发票过期时间，如果不适用则可选
        "settled_at": unixtimestamp, // 发票/支付结算时间
        "metadata": {} // 可用于添加打赏/增强图详细信息的付款人姓名/评论等的通用元数据。
    }
}
```

### `payment_sent`

描述：钱包成功发送支付。

通知：
```jsonc
{
    "notification_type": "payment_sent",
    "notification": {
        "type": "outgoing",
        "state": "settled", // 可选
        "invoice": "string", // 编码的发票
        "description": "string", // 发票的描述，可选
        "description_hash": "string", // 发票的描述哈希，可选
        "preimage": "string", // 支付的原像
        "payment_hash": "string", // 支付的支付哈希
        "amount": 123, // 毫聪值
        "fees_paid": 123, // 毫聪值
        "created_at": unixtimestamp, // 发票/支付创建时间
        "expires_at": unixtimestamp, // 发票过期时间，如果不适用则可选
        "settled_at": unixtimestamp, // 发票/支付结算时间
        "metadata": {} // 可用于添加打赏/增强图详细信息的付款人姓名/评论等的通用元数据。
    }
}
```

## 支付发票流程示例

0. 用户使用其 **客户端** 应用程序扫描 **钱包服务** 生成的二维码，他们遵循 `nostr+walletconnect://` 深度链接或手动配置连接详细信息。
1. **客户端** 向 **钱包服务** 发送种类 `23194` 的事件。内容是 `pay_invoice` 请求。私钥是上面连接字符串中的秘密。
2. **钱包服务** 验证作者的密钥是否有权执行支付，解密载荷并发送支付。
3. **钱包服务** 通过发送种类 `23195` 的事件和包含错误消息或原像的响应内容来响应事件。

## 加密

NWC 的初始版本使用 [NIP-04](04.md) 进行加密，该加密已被弃用并被 [NIP-44](44.md) 替代。应始终优先使用 NIP-44 进行加密，但可能存在 **钱包服务** 或 **客户端** 尚未迁移到 NIP-44 的传统情况。**钱包服务** 和 **客户端** 应该根据 `info` 事件中的 `encryption` 标签协商要使用的加密方法。

加密标签可以包含 `nip44_v2` 或 `nip04`。没有此标签意味着钱包仅支持 `nip04`。

| 加密代码 | 使用                  | 说明                                                   |
|-----------------|----------------------|---------------------------------------------------------|
| `nip44_v2`      | NIP-44               | 必需                                                |
| `nip04`         | NIP-04               | 已弃用，仅为向后兼容                     |
| `<不存在>` | NIP-04               | 已弃用，仅为向后兼容                     |

协商工作如下。

1. **钱包服务** 在 `info` 事件中包含 `encryption` 标签。此标签包含 **钱包服务** 支持的加密方案的空格分隔列表（例如 `nip44_v2 nip04`）
2. **客户端应用程序** 在每个请求事件中包含 `encryption` 标签。此标签包含应该用于请求的加密方案。如果 **钱包服务** 支持 nip44，**客户端应用程序** 应始终优先使用 nip44。

### Info 事件

首先，**钱包服务** 向其 `info` 事件添加 `encryption` 标签，包含它支持的加密方案的空格分隔列表。例如，如果钱包服务支持 nip44，但也允许向后兼容 nip04 客户端应用程序，其 `info` 事件中的 `encryption` 标签可能如下所示：

```jsonc
{
    "kind": 13194,
    "tags": [
        ["encryption", "nip44_v2 nip04"],
        // ...
    ],
    "content": "pay_invoice get_balance make_invoice lookup_invoice list_transactions get_info",
    // ...
}
```

当 **客户端应用程序** 建立连接时，它应该读取 info 事件并查找 `encryption` 标签。

**没有此标签意味着钱包仅支持 nip04。**

如果存在 `encryption` 标签，**客户端应用程序** 将选择它自己和 **钱包服务** 都支持的最佳加密，如果可能的话应该始终是 nip44。

### 请求事件

当 **客户端应用程序** 发送请求事件时，它应该包含一个带有它正在使用的加密方案的 `encryption` 标签。该方案必须由 **钱包服务** 支持，如 info 事件所示。
例如，如果客户端应用程序支持 nip44，请求事件可能如下所示：

```jsonc
{
    "kind": 23194,
    "tags": [
        ["encryption", "nip44_v2"],
        // ...
    ],
    // ...
}
```

如果 **钱包服务** 不支持指定的加密方案，它将返回 `UNSUPPORTED_ENCRYPTION` 错误。没有 `encryption` 标签表示使用 nip04 进行加密。

### 通知事件

如上面[通知](#notifications)部分所述，如果 **钱包服务** 同时支持 nip04 和 nip44，它应该为每个通知发布两个通知事件 - 用 NIP-04 加密的种类 23196 和用 NIP-44 加密的种类 23197。如果 **钱包服务** 仅支持 nip44，它应该仅发布种类 23197 事件。

**客户端** 应该检查 `info` 事件中的 `encryption` 标签以确定 **钱包服务** 支持哪些加密方案，并监听相应的通知事件。

## 使用专用中继器
此 NIP 没有指定对所使用的中继器类型的任何要求。但是，如果用户使用托管服务，使用由托管服务托管的中继器可能是有意义的。然后中继器可以强制执行身份验证以防止元数据泄露。在这种情况下，不依赖第三方中继器也会提高可靠性。

## 元数据
元数据可能由 **钱包服务** 与发票和支付一起存储。元数据不得超过 4096 个字符，否则必须丢弃。这是为了确保交易不会变得太大而无法中继。

NWC 中继器应该允许至少 64KB 的载荷大小，**客户端** 应该获取小页面大小（每页最多 20 个交易），否则存在 `list_transactions` 响应被拒绝的风险。

以下是一些 NWC 客户端识别的属性：

```jsonc
{
  "comment": "string", // LUD-12 评论
  "payer_data": {
    "email": "string",
    "name": "string",
    "pubkey": "string",
  }, // LUD-18 付款人数据
  "recipient_data": {
    "identifier": "string"
  }, // 类似于 LUD-18 付款人数据，但用于记录收款人数据，例如收款人的闪电地址
  "nostr": {
    "pubkey": "string",
    "tags": [],
    // ... 
  }, // NIP-57 (Nostr Zaps)
  "tlv_records": [ // tlv 记录，可选
    {
      "type": 5482373484, // tlv 类型
      "value": "0123456789abcdef" // 十六进制编码的 tlv 值
    }
  ] // keysend TLV 记录（例如用于播客 2.0 增强图）
} & Record<string, unknown>;
```

## 附录

### NIP-47 info 事件示例

```jsonc
{
  "id": "df467db0a9f9ec77ffe6f561811714ccaa2e26051c20f58f33c3d66d6c2b4d1c",
  "pubkey": "c04ccd5c82fc1ea3499b9c6a5c0a7ab627fbe00a0116110d4c750faeaecba1e2",
  "created_at": 1713883677,
  "kind": 13194,
  "tags": [
    [ "encryption", "nip44_v2 nip04" ],
    [
      "notifications",
      "payment_received payment_sent"
    ]
  ],
  "content": "pay_invoice pay_keysend get_balance get_info make_invoice lookup_invoice list_transactions multi_pay_invoice multi_pay_keysend sign_message notifications",
  "sig": "31f57b369459b5306a5353aa9e03be7fbde169bc881c3233625605dd12f53548179def16b9fe1137e6465d7e4d5bb27ce81fd6e75908c46b06269f4233c845d8"
}
```
