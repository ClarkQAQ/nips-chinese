NIP-49
======

私钥加密
----------------------

`草案` `可选`

本 NIP 定义了一种客户端可以使用密码加密（和解密）用户私钥的方法。

对称加密密钥派生
-----------------------------------

PASSWORD = 从用户读取。密码应该使用 Unicode 标准化为 NFKC 格式，以确保密码可以在其他计算机/客户端上相同地输入。

LOG\_N = 让用户或实现者选择一个字节，表示 2 的幂（例如 18 表示 262,144），用作 scrypt 的轮数。更大的数字需要更多时间和更多内存，并提供更好的保护：

    | LOG_N | 所需内存        | 快速计算机上的大约时间        |
    |-------|-----------------|----------------------------- |
    | 16    | 64 MiB          | 100 ms                       |
    | 18    | 256 MiB         |                              |
    | 20    | 1 GiB           | 2 秒                         |
    | 21    | 2 GiB           |                              |
    | 22    | 4 GiB           |                              |

SALT = 16 个随机字节

SYMMETRIC_KEY = scrypt(password=PASSWORD, salt=SALT, log\_n=LOG\_N, r=8, p=1)

对称密钥应该是 32 字节长。

此对称加密密钥是临时的，应该在使用后清零并丢弃，不得存储或重复用于任何其他目的。


加密私钥
------------------------

私钥加密过程如下：

PRIVATE\_KEY = 用户的私有（秘密）secp256k1 密钥，作为 32 个原始字节（不是十六进制或 bech32 编码！）

KEY\_SECURITY\_BYTE = 以下之一：

*  0x00 - 如果已知密钥曾被不安全地处理（未加密存储、未加密剪切和粘贴等）
*  0x01 - 如果未知密钥曾被不安全地处理（未加密存储、未加密剪切和粘贴等）
* 0x02 - 如果客户端不跟踪此数据

ASSOCIATED\_DATA = KEY\_SECURITY\_BYTE

NONCE = 24 字节随机随机数

CIPHERTEXT = XChaCha20-Poly1305(
    plaintext=PRIVATE\_KEY,
    associated_data=ASSOCIATED\_DATA,
    nonce=NONCE,
    key=SYMMETRIC\_KEY
)

VERSION\_NUMBER = 0x02

CIPHERTEXT_CONCATENATION = concat(
    VERSION\_NUMBER,
    LOG\_N,
    SALT,
    NONCE,
    ASSOCIATED\_DATA,
    CIPHERTEXT
)

ENCRYPTED\_PRIVATE\_KEY = bech32_encode('ncryptsec', CIPHERTEXT\_CONCATENATION)

bech32 编码前的输出应该是 91 字节长。

解密过程相反操作。


测试数据
---------

## 密码 Unicode 标准化

以下密码输入："ÅΩẛ̣"
- Unicode 代码点：U+212B U+2126 U+1E9B U+0323
- UTF-8 字节：[0xE2, 0x84, 0xAB, 0xE2, 0x84, 0xA6, 0xE1, 0xBA, 0x9B, 0xCC, 0xA3]

应该在用于 scrypt 之前转换为 unicode 标准化 NFKC 格式："ÅΩẛ̣"
- Unicode 代码点：U+00C5 U+03A9 U+1E69
- UTF-8 字节：[0xC3, 0x85, 0xCE, 0xA9, 0xE1, 0xB9, 0xA9]

## 加密

由于随机随机数，加密过程是非确定性的。

## 解密

以下加密私钥：

`ncryptsec1qgg9947rlpvqu76pj5ecreduf9jxhselq2nae2kghhvd5g7dgjtcxfqtd67p9m0w57lspw8gsq6yphnm8623nsl8xn9j4jdzz84zm3frztj3z7s35vpzmqf6ksu8r89qk5z2zxfmu5gv8th8wclt0h4p`

使用密码='nostr' 和 log_n=16 解密时产生以下十六进制编码的私钥：

`3501454135014541350145413501453fefb02227e449e57cf4d3a3ce05378683`

讨论
----------

### 关于密钥派生

密码是糟糕的加密密钥。在用作加密密钥之前，需要发生两件事：

1. 需要从密码确定性地创建加密密钥，使其具有均匀的功能随机位分布，使得对称加密算法的假设有效，并且
2. 应该在过程中注入慢速不可逆算法，以便通过尝试多个密码进行暴力破解的尝试受到严重阻碍。

这些是使用基于密码的密钥派生函数实现的。我们使用 scrypt，它已被证明具有最大内存困难性，几位密码学家向作者表示，即使 argon2 在 2015 年赢得了竞赛，scrypt 也比 argon2 更好。

### 关于对称加密算法

密码学家通常偏爱 XChaCha20-Poly1305 而不是 AES，并且与美国政府的关联较少。它（或其早期变体，没有'X'）正在广泛使用，在 TLS 和 OpenSSH 中使用，并且在大多数现代加密库中可用。

建议
---------

不建议用户将这些加密私钥发布到 nostr，因为当攻击者可以收集许多加密私钥时，破解密钥可能变得更容易。

建议客户端在释放内存之前清零密码和私钥的内存。
