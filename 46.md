NIP-46
======

Nostr 远程签名
--------------------

## 变更

引入了 `remote-signer-key`，在 bunker URL 中传递，客户端必须区分 `remote-signer-pubkey` 和 `user-pubkey`，必须在连接后调用 `get_public_key`，移除了 nip05 登录，create_account 移至另一个 NIP。

## 原理

私钥应该暴露给尽可能少的系统——应用程序、操作系统、设备——因为每个系统都会增加攻击面。

本 NIP 描述了远程签名器和 Nostr 客户端之间双向通信的方法。远程签名器可以是，例如，专用于签署 Nostr 事件的硬件设备，而客户端是普通的 Nostr 客户端。

## 术语

- **用户**：试图使用 Nostr 的人。
- **客户端**：_用户_ 正在查看和点击按钮的面向用户的应用程序。此应用程序将向 _远程签名器_ 发送请求。
- **远程签名器**：在某处运行的守护进程或服务器，将回答来自 _客户端_ 的请求，也称为"bunker"。
- **客户端密钥对/公钥**：由 _客户端_ 生成的密钥。用于加密内容并与 _远程签名器_ 通信。
- **远程签名器密钥对/公钥**：_远程签名器_ 用于加密内容并与 _客户端_ 通信的密钥。此密钥对可能与 _用户密钥对_ 相同，但不一定。
- **用户密钥对/公钥**：表示 _用户_ 的实际密钥（例如，将用于响应 `sign_event` 请求签署事件）。_远程签名器_ 通常控制这些密钥。

本 NIP 中指定的所有公钥都是十六进制格式。

## 概述

1. _客户端_ 生成 `client-keypair`。此密钥对不需要传达给 _用户_，因为它在很大程度上是可丢弃的。_客户端_ 可能选择在本地存储它，并应在注销时删除它；
2. 建立连接（见下文），_远程签名器_ 学习 `client-pubkey`，_客户端_ 学习 `remote-signer-pubkey`。
3. _客户端_ 使用 `client-keypair` 通过 `p` 标记并加密到 `remote-signer-pubkey` 向 _远程签名器_ 发送请求；
4. _远程签名器_ 通过 `p` 标记并加密到 `client-pubkey` 响应 _客户端_。
5. _客户端_ 请求 `get_public_key` 来学习 `user-pubkey`。

## 发起连接

有两种发起连接的方式：

### 由 _远程签名器_ 发起的直接连接

_远程签名器_ 提供以下形式的连接令牌：

```
bunker://<remote-signer-pubkey>?relay=<wss://relay-to-connect-on>&relay=<wss://another-relay-to-connect-on>&secret=<optional-secret-value>
```

_用户_ 将此令牌传递给 _客户端_，然后客户端通过指定的中继器向 _远程签名器_ 发送 `connect` 请求。可选秘密只能用于单个成功建立的连接，_远程签名器_ 应该忽略使用旧秘密建立连接的新尝试。

### 由 _客户端_ 发起的直接连接

_客户端_ 使用 `nostrconnect://` 作为协议提供连接令牌，以 `client-pubkey` 作为来源。其他信息应作为查询参数传递：

- `relay`（必需）- _客户端_ 正在监听来自 _远程签名器_ 响应的一个或多个中继器 URL。
- `secret`（必需）- _远程签名器_ 应作为其响应的 `result` 字段返回的短随机字符串。
- `perms`（可选）- _客户端_ 请求 _远程签名器_ 批准的权限的逗号分隔列表
- `name`（可选）- _客户端_ 应用程序的名称
- `url`（可选）- _客户端_ 应用程序的规范 URL
- `image`（可选）- 表示 _客户端_ 应用程序的小图像

这是一个示例：

```
nostrconnect://83f3b2ae6aa368e8275397b9c26cf550101d63ebaab900d19dd4a4429f5ad8f5?relay=wss%3A%2F%2Frelay1.example.com&perms=nip44_encrypt%2Cnip44_decrypt%2Csign_event%3A13%2Csign_event%3A14%2Csign_event%3A1059&name=My+Client&secret=0s8j2djs&relay=wss%3A%2F%2Frelay2.example2.com
```

_用户_ 将此令牌传递给 _远程签名器_，然后远程签名器通过指定的中继器向 `client-pubkey` 发送 `connect` *响应* 事件。客户端从连接响应作者发现 `remote-signer-pubkey`。必须提供 `secret` 值以避免连接欺骗，_客户端_ 必须验证 `connect` 响应返回的 `secret`。

## 请求事件 `kind: 24133`

```jsonc
{
    "kind": 24133,
    "pubkey": <local_keypair_pubkey>,
    "content": <nip44(<request>)>,
    "tags": [["p", <remote-signer-pubkey>]],
}
```

`content` 字段是类似 JSON-RPC 的消息，使用 [NIP-44](44_ZH.md) 加密，具有以下结构：

```jsonc
{
    "id": <random_string>,
    "method": <method_name>,
    "params": [array_of_strings]
}
```

- `id` 是请求 ID 的随机字符串。相同的 ID 将在响应载荷中发送回来。
- `method` 是方法/命令的名称（详见下文）。
- `params` 是字符串参数的位置数组。

### 方法/命令

以下每个都是 _客户端_ 向 _远程签名器_ 发送的方法。

| 命令                  | 参数                                                                        | 结果                                                                 |
| ------------------------ | -------------------------------------------------                             | ---------------------------------------------------------------------- |
| `connect`                | `[<remote-signer-pubkey>, <optional_secret>, <optional_requested_permissions>]`        | "ack" 或 `<required-secret-value>`                                                                  |
| `sign_event`             | `[<{kind, content, tags, created_at}>]`                                       | `json_stringified(<signed_event>)`                                     |
| `ping`                   | `[]`                                                                          | "pong"                                                                 |
| `get_public_key`         | `[]`                                                                          | `<user-pubkey>`                                                         |
| `nip04_encrypt`          | `[<third_party_pubkey>, <plaintext_to_encrypt>]`                              | `<nip04_ciphertext>`                                                   |
| `nip04_decrypt`          | `[<third_party_pubkey>, <nip04_ciphertext_to_decrypt>]`                       | `<plaintext>`                                                          |
| `nip44_encrypt`          | `[<third_party_pubkey>, <plaintext_to_encrypt>]`                              | `<nip44_ciphertext>`                                                   |
| `nip44_decrypt`          | `[<third_party_pubkey>, <nip44_ciphertext_to_decrypt>]`                       | `<plaintext>`                                                          |

### 请求权限

`connect` 方法可能提供 `optional_requested_permissions` 以方便用户。权限是 `method[:params]` 的逗号分隔列表，即 `nip44_encrypt,sign_event:4` 意味着调用 `nip44_encrypt` 的权限和调用 `kind:4` 的 `sign_event` 的权限。`sign_event` 的可选参数是种类号，其他方法的参数稍后定义。相同的权限格式可用于 `nostrconnect://` 字符串中 `metadata` 的 `perms` 字段。

## 响应事件 `kind:24133`

```json
{
    "id": <id>,
    "kind": 24133,
    "pubkey": <remote-signer-pubkey>,
    "content": <nip44(<response>)>,
    "tags": [["p", <client-pubkey>]],
    "created_at": <unix timestamp in seconds>
}
```

`content` 字段是类似 JSON-RPC 的消息，使用 [NIP-44](44_ZH.md) 加密，具有以下结构：

```json
{
    "id": <request_id>,
    "result": <results_string>,
    "error": <optional_error_string>
}
```

- `id` 是此响应对应的请求 ID。
- `results` 是调用结果的字符串（这可以是字符串或 JSON 字符串化对象）
- `error`，_可选地_，它是字符串形式的错误，如果有的话。它的存在表示请求有错误。

## 签署事件的示例流程

- `remote-signer-pubkey` 是 `fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52`
- `user-pubkey` 也是 `fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52`
- `client-pubkey` 是 `eff37350d839ce3707332348af4549a96051bd695d3223af4aabce4993531d86`

### 签名请求

```jsonc
{
    "kind": 24133,
    "pubkey": "eff37350d839ce3707332348af4549a96051bd695d3223af4aabce4993531d86",
    "content": nip44({
        "id": <random_string>,
        "method": "sign_event",
        "params": [json_stringified(<{
            content: "你好，我正在远程签名",
            kind: 1,
            tags: [],
            created_at: 1714078911
        }>)]
    }),
    "tags": [["p", "fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52"]], // p-标记远程签名器公钥
}
```

### 响应事件

```jsonc
{
    "kind": 24133,
    "pubkey": "fa984bd7dbb282f07e16e7ae87b26a2a7b9b90b7246a44771f0cf5ae58018f52",
    "content": nip44({
        "id": <random_string>,
        "result": json_stringified(<signed-event>)
    }),
    "tags": [["p", "eff37350d839ce3707332348af4549a96051bd695d3223af4aabce4993531d86"]], // p-标记客户端公钥
}
```

### 图表

![signing-example](https://i.nostr.build/P3gW.png)


## 认证挑战

认证挑战是 _远程签名器_ 在需要 _用户_ 通过其他方式认证时可以发送回的响应。响应 `content` 对象将采用以下形式：

```json
{
    "id": <request_id>,
    "result": "auth_url",
    "error": <URL_to_display_to_end_user>
}
```

_客户端_ 应该显示（在弹出窗口或新标签中）来自 `error` 字段的 URL，然后订阅/监听来自 _远程签名器_ 的另一个响应（重用相同的请求 ID）。一旦用户在其他窗口中认证（如果用户不认证则永远不会到达），将发送此事件。

### 带有认证挑战的事件签名请求示例

![signing-example-with-auth-challenge](https://i.nostr.build/W3aj.png)

## 附录

### 宣布 _远程签名器_ 元数据

_远程签名器_ 可以通过使用 [NIP-05](05_ZH.md) 和 [NIP-89](89_ZH.md) 发布其元数据。使用 NIP-05，对 `<remote-signer>/.well-known/nostr.json?name=_` 的请求可能返回：
```jsonc
{
    "names":{
        "_": <remote-signer-app-pubkey>,
    },
    "nip46": {
        "relays": ["wss://relay1","wss://relay2"...],
        "nostrconnect_url": "https://remote-signer-domain.example/<nostrconnect>"
    }
}
```

`<remote-signer-app-pubkey>` 可以用于从 _远程签名器_ 的 NIP-89 事件验证域（见下文）。`relays` 应该用于为特定 `remote-signer` 构造更精确的 `nostrconnect://` 字符串。`nostrconnect_url` 模板可以用于通过用实际 `nostrconnect://` 字符串替换 `<nostrconnect>` 占位符来将用户重定向到 _远程签名器_ 的连接流程。

### 通过 NIP-89 发现远程签名器

_远程签名器_ 可能发布带有 `k` 标签为 `24133` 的 NIP-89 `kind: 31990` 事件，也可能包含一个或多个 `relay` 标签和可能包含 `nostrconnect_url` 标签。`relay` 和 `nostrconnect_url` 标签的语义与上面部分相同。

_客户端_ 可以通过使用其 `kind: 31990` 事件发现 _远程签名器_ 来改善用户体验。_客户端_ 然后可以为 _远程签名器_ 预生成 `nostrconnect://` 字符串，在这种情况下应该验证 `kind: 31990` 事件的作者在签名器的 `nostr.json?name=_` 文件中作为 `<remote-signer-app-pubkey>` 被提及。
