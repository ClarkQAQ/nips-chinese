NIP-88
======

投票
-----

`草案` `可选`

此 NIP 定义了描述 nostr 上投票的事件方案。

## 事件

### 投票事件

投票事件定义为 `kind:1068` 事件。

- **content** 键保存投票的标签。

投票事件中的主要标签有：

- **option**：选项标签包含一个 OptionId（任何字母数字）字段，后跟一个选项标签字段。
- **relay**：投票期望响应者响应的一个或多个标签。
- **polltype**：可以是 "singlechoice" 或 "multiplechoice"。没有 polltype 的投票应该被认为是 "singlechoice" 投票。
- **endsAt**：表示投票预计结束的 unix 时间戳。

示例事件

```json
{
  "content": "披萨上的菠萝",
  "created_at": 1719888496,
  "id": "9d1b6b9562e66f2ecf35eb0a3c2decc736c47fddb13d6fb8f87185a153ea3634",
  "kind": 1068,
  "pubkey": "dee45a23c4f1d93f3a2043650c5081e4ac14a778e0acbef03de3768e4f81ac7b",
  "sig": "7fa93bf3c430eaef784b0dacc217d3cd5eff1c520e7ef5d961381bc0f014dde6286618048d924808e54d1be03f2f2c2f0f8b5c9c2082a4480caf45a565ca9797",
  "tags": [
    ["option", "qj518h583", "赞成"],
    ["option", "gga6cdnqj", "反对"],
    ["relay", "<中继URL1>"],
    ["relay", "<中继URL2>"],
    ["polltype", "singlechoice"],
    ["endsAt", "<以秒为单位的unix时间戳>"]
  ]
}
```

### 响应

响应事件是 `kind:1018` 事件。它包含一个引用投票事件的 e 标签，后跟一个或多个响应标签。

- **response**：标签包含 "response" 作为其第一个位置参数，后跟选择的选项 Id。

响应应该发布到投票事件中指定的中继器。

示例响应事件

```json
{
  "content": "",
  "created_at": 1720097117,
  "id": "60a005e32e9596c3f544a841a9bc4e46d3020ca3650d6a739c95c1568e33f6d8",
  "kind": 1018,
  "pubkey": "1bc70a0148b3f316da33fe7e89f23e3e71ac4ff998027ec712b905cd24f6a411",
  "sig": "30071a633c65db8f3a075c7a8de757fbd8ce65e3607f4ba287fe6d7fbf839a380f94ff4e826fbba593f6faaa13683b7ea9114ade140720ecf4927010ebf3e44f",
  "tags": [
    ["e", "1fc80cf813f1af33d5a435862b7ef7fb96b47e68a48f1abcadf8081f5a545550"],
    ["response", "gga6cdnqj"],
    ["response", "m3agjsdq1"]
  ]
}
```

### 投票类型

polltype 设置决定了如何处理 `kind:1018` 事件中的多个响应标签。

- **polltype: singlechoice**：第一个响应标签被认为是实际响应。
- **polltype: multiplechoice**：指向每个 id 的第一个响应标签被认为是实际响应，不考虑响应标签的顺序。

### 计算结果

可以通过从投票中指定的中继器获取 `kind:1018` 事件来查询结果。
显示的结果应该只是每个公钥一个投票事件。
如果一个公钥有多个事件，应该考虑投票限制内时间戳最大的事件。

查询投票的示例。

```ts
const fetchVoteEvents = (filterPubkeys: string[]) => {
  let resultFilter: Filter = {
    "#e": [pollEvent.id],
    kinds: [1018],
  };
  if (filterPubkeys?.length) {
    resultFilter.authors = filterPubkeys;
  }
  if (pollExpiration) {
    resultFilter.until = Number(pollExpiration);
  }
  pool.subscribeMany(relays, [resultFilter], {
    onevent: handleResultEvent,
  });
};
```

维护每个公钥一票的示例

```ts
const oneVotePerPubkey = (events: Event[]) => {
  const eventMap = new Map<string, Event>();

  events.forEach((event) => {
    if (
      !eventMap.has(event.pubkey) ||
      event.created_at > eventMap.get(event.pubkey)!.created_at
    ) {
      eventMap.set(event.pubkey, event);
    }
  });

  return Array.from(eventMap.values());
};
```

### 中继器

建议投票作者使用不允许回溯事件且不接受投票事件的 kind:5（删除）请求的中继器，以便在投票结束后保持投票结果的完整性。

### 策划

客户端可以配置通过特定人员获取结果。这可以通过创建 `kind:30000` 关注集合并仅从关注集合中获取结果来实现。
客户端还可以采用其他策划算法，如工作量证明和信任网络分数来进行结果策划。
